# Environmental hazards-spatial models {#hazards}

This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics:

- Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps.
- Exploring the underlying structure of spatial data and methods for characterizing dependence over space.
- Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations.
- Stationarity and isotropy.
- Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging).
- Non-stationarity fields.

<!-- NOTE: I know this might not be what we agreed on but I don't like the codes that are available for this chapter, some of them are incomplete and some of them are repeated so I am doing some of them all over again with the UK ozone data, but you can decide to change it later if you wish. -->


## Example 10.1 {-}

Map the locations of the monitoring stations in the UK.

```{r Ex 10.1 load data, message = FALSE, warning=FALSE, error=FALSE}

library(geoR)
library(ggmap)
library(spdep)

uk_data <- read.csv("data/uk_ozone_uni.csv")

# create a new variable in "sp" format 
uk_data_sp <- uk_data
coordinates(uk_data_sp) <- ~ longitude + latitude

# specify the projection code
proj4string(uk_data_sp) <- CRS("+proj=longlat +ellps=WGS84")

# Specify the bounding box 
latLongBox = bbox(uk_data_sp)
location = c(latLongBox[1, 1] - 0.2,
             latLongBox[2, 1] - 0,
             latLongBox[1, 2] + 0.2,
             latLongBox[2, 2] + 0.2)

# Create map with location dots marked on it in
UKOzoneMap <-
  get_stamenmap(
    bbox = location,
    zoom = 6
  )

ggmap(UKOzoneMap) + geom_point(
  data = uk_data,
  aes(
    x = longitude,
    y = latitude,
    size = ozone,
    color = ozone
  ),
  alpha = 0.45
) + theme_void()

```

Using the `geoR` package we can also plot the following:

-  the locations of the sampling sites 
-  the concentrations of ozone in relation to the x and y coordinates
- and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density.

```{r Ex 10.1 geoR plot}

uk_data_geo <- as.geodata(uk_data,
                          coords.col = 2:3, data.col = 4)

plot(uk_data_geo)

```


## Example 10.9 {-}


NOTE: This won't be the real example but I need to compare it to something that I know the answer to, so instead of doing a simulation I will keep going by analyzing the meuse river data

### Nimble {-}

```{r Ex 10.9 load data, message = FALSE, warning=FALSE, error=FALSE}

rm(list=ls())
library(sp)
library(nimble)
```

```{r Ex 10.9 load data sim}

data(meuse)

# Extract the zinc data in the log scale from the meuse dataset
meusesample <-
  data.frame(
    y = log(meuse$zinc),
    x1 = sqrt(meuse$dist),
    easting = meuse$x / 1000,
    northing = meuse$y / 1000
  )

# Compute the distance matrix
Dist <- as.matrix(dist(meusesample[,c("easting", "northing")]))

```


```{r Ex 10.9 nimble model}

Example10_9Code <-  nimbleCode ({
  # Covariance matrix spatial effect
  Sigma[1:n, 1:n] <- (sigma^2)*exp(-distMatrix[1:n,1:n]/phi) + (tau^2)*identityMatrix(d = n)
  
  for (site in 1:n) {
    mean.site[site] <- beta0 + beta1 * x[site]
  }
  
  y[1:n]  ~  dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n])
  
  # Set up the priors for the spatial model
  sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  phi_inv ~ dgamma(shape =  8186.436, rate = 12026.879)
  phi <- 1/phi_inv
  
  # prior for the intercept term
  beta0 ~ dnorm (0, 10)
  beta1 ~ dnorm (0, 10)
  
  
}) 

```


Define the constants, data and initials lists for the `nimble` model.



```{r nimble Ex 10.9 set constants and inits, error = FALSE, message = FALSE, results='hide'}

# Get the distance matrix using by turning it into an sf object

constants <-
  list(n = nrow(meusesample))
ex.data <- list(y = meusesample$y, x = meusesample$x1, distMatrix = Dist)

params <- c( "tau",  "beta0", "beta1", "sigma", "phi")
inits <- list(tau = 0.1, beta0 = 1, beta1 = 1, sigma = 0.1, phi_inv = 6/max(Dist))
# TODO: I have to check this code with a simulation first 
mcmc.out <- nimbleMCMC(
  code = Example10_9Code,
  constants = constants,
  data = ex.data,
  inits = inits,
  monitors = params,
  niter = 10000,
  nburnin = 5000,
  thin = 14,
  WAIC = TRUE,
  nchains = 2,
  summary = TRUE,
  samplesAsCodaMCMC = TRUE
)

```

```{r Ex 10.9 nimble WAIC, ESS and traceplots }

mcmc.out$WAIC
min(coda::effectiveSize(mcmc.out$samples))
# REVIEW: the effective size for sigma is really low, look at the traceplot
# NOTE: there might not be a spatial structure...
plot(mcmc.out$samples[, c("beta0")])
plot(mcmc.out$samples[, c("beta1")])

#plot(mcmc.out$samples[, c("sigma")])
plot(mcmc.out$samples[, c("tau")])
#plot(mcmc.out$samples[, c("phi")])

mcmc.out$summary$all.chains

```








# Environmental hazards-spatial models {#hazards}

This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics:

- Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps.
- Exploring the underlying structure of spatial data and methods for characterizing dependence over space.
- Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations.
- Stationarity and isotropy.
- Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging).
- Non-stationarity fields.

<!-- NOTE: I know this might not be what we agreed on but I don't like the codes that are available for this chapter, some of them are incomplete and some of them are repeated so I am doing some of them all over again with the UK ozone data, but you can decide to change it later if you wish. -->


## Example 10.1 {-}

Map the locations of the monitoring stations in the UK.

```{r Ex 10.1 load data, message = FALSE, warning=FALSE, error=FALSE}

library(geoR)
library(ggmap)
library(spdep)

benzene_data <- read.csv("data/montreal_benzene.csv")

# create a new variable in "sp" format 
benzene_data_geo <- benzene_data
coordinates(benzene_data_geo) <- ~ lon+lat
proj4string(benzene_data_geo) <- CRS("+proj=longlat +datum=WGS84")

# Specify the bounding box 
latLongBox = bbox(benzene_data_geo)
location = c(latLongBox[1, 1] - 0.2,
             latLongBox[2, 1] - 0.05,
             latLongBox[1, 2] + 0.1,
             latLongBox[2, 2] + 0.05)

# Create map with location dots marked on it in
MontrelBenzeneMap <-
  get_stamenmap(
    bbox =  location,
    zoom = 11
  )

ggmap(MontrelBenzeneMap) + geom_point(
  data = benzene_data,
  aes(
    x = lon,
    y = lat,
    size = Benzene,
    color = Benzene
  ),
  alpha = 0.45
) + theme_void()

```

Using the `geoR` package we can also plot the following:

-  the locations of the sampling sites 
-  the concentrations of ozone in relation to the x and y coordinates
- and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density.

```{r Ex 10.1 geoR plot}
# Convert data to utm 
benzene_data_utm <- spTransform(benzene_data_geo,
                        CRS("+proj=utm +zone=18 +ellps=WGS72"))

benzene_utm_df <- as.data.frame(benzene_data_utm)
colnames(benzene_utm_df) <- c("ID", "Benzene", "X", "Y")

benzene_geodata <- as.geodata(benzene_utm_df,
                          coords.col = 3:4, data.col = 2)

plot(benzene_geodata)

hist(log(benzene_utm_df$Benzene), main = "log(benzene)")
qqnorm(log(benzene_utm_df$Benzene), bty = "n")
qqline(log(benzene_utm_df$Benzene))

```
## Example 10.5 {-}


```{r Ex 10.5 plot variogram}
CA.vario4 <- variog(benzen, uvec = seq(0,8,l=8))
plot(CA.vario4)
```


## Example 10.9 {-}


NOTE: This won't be the real example but I need to compare it to something that I know the answer to, so instead of doing a simulation I will keep going by analyzing the meuse river data

### Nimble {-}

```{r Ex 10.9 load data, message = FALSE, warning=FALSE, error=FALSE}

library(sp)
library(nimble)
```

```{r Ex 10.9 load data sim}

data(meuse)

# Extract the zinc data in the log scale from the meuse dataset
benzenesample <-
  data.frame(
    y = log(benzene_utm_df$Benzene),
    easting = benzene_utm_df$X / 1000,
    northing = benzene_utm_df$Y / 1000
  )

# Compute the distance matrix
Dist <- as.matrix(dist(benzenesample[,c("easting", "northing")]))

```



```{r Ex 10.9 nimble model}

Example10_9Code <-  nimbleCode ({
  # Covariance matrix spatial effect
  Sigma[1:n, 1:n] <- (sigma^2)*exp(-distMatrix[1:n,1:n]/phi) + (tau^2)*identityMatrix(d = n)
  
  for (site in 1:n) {
    mean.site[site] <- beta0 + beta1*easting[site] + beta2*northing[site]
  }
  
  y[1:n]  ~  dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n])
  
  # Set up the priors for the spatial model
  sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  phi_inv ~ dgamma(shape =  8186.436, rate = 12026.879)
  phi <- 1/phi_inv
  
  # prior for the coefficients term
    beta0 ~ dnorm (0, 10)
    beta1 ~ dnorm (0, 10)
    beta2 ~ dnorm (0, 10)

}) 

```


Define the constants, data and initials lists for the `nimble` model.



```{r nimble Ex 10.9 set constants and inits, error = FALSE, message = FALSE, results='hide'}

# Get the distance matrix using by turning it into an sf object

constants <-
  list(n = nrow(benzenesample))
ex.data <-
  list(y = benzenesample$y,
       easting = as.vector(scale(benzenesample$easting)),
       northing = as.vector(scale(benzenesample$northing)),
       distMatrix = Dist)

params <- c( "tau",  "beta0", "beta1","beta2", "sigma", "phi")
inits <- list(tau = 0.1, sigma = 0.1, phi_inv = 6/max(Dist))
# TODO: I have to check this code with a simulation first 
mcmc.out <- nimbleMCMC(
  code = Example10_9Code,
  constants = constants,
  data = ex.data,
  inits = inits,
  monitors = params,
  niter = 10000,
  nburnin = 5000,
  thin = 14,
  WAIC = TRUE,
  nchains = 2,
  summary = TRUE,
  samplesAsCodaMCMC = TRUE
)

```

```{r Ex 10.9 nimble WAIC, ESS and traceplots }

mcmc.out$WAIC
min(coda::effectiveSize(mcmc.out$samples))
# REVIEW: the effective size for sigma is really low, look at the traceplot
# NOTE: there might not be a spatial structure...
plot(mcmc.out$samples[, c("beta0")])
plot(mcmc.out$samples[, c("beta1")])
plot(mcmc.out$samples[, c("beta2")])


#plot(mcmc.out$samples[, c("sigma")])
plot(mcmc.out$samples[, c("tau")])
#plot(mcmc.out$samples[, c("phi")])

mcmc.out$summary$all.chains

```








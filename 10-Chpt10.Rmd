# Environmental hazards-spatial models {#hazards}

This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics:

- Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps.
- Exploring the underlying structure of spatial data and methods for characterizing dependence over space.
- Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations.
- Stationarity and isotropy.
- Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging).
- Non-stationarity fields.

<!-- NOTE: Unlike some of the other chapters you have to run this code sequentially -->


## Example 10.1 Spatial patterns of benzene concentrations in Montreal, QC, Canada {-}

Map the locations of the monitoring stations in Montreal.

```{r Ex 10.1 load data, message = FALSE, warning=FALSE, error=FALSE}
library(cowplot)
library(geoR)
library(ggmap)
library(spdep)
# Load data on benzene concentration in Montreal
benzene_data <- read.csv("data/montreal_benzene_apr.csv")
```

```{r Ex 10.1 map data, message = FALSE, warning=FALSE, error=FALSE}
# create a new variable in "sp" format and define coordinates
benzene_data_geo <- benzene_data
coordinates(benzene_data_geo) <- ~ lon + lat
proj4string(benzene_data_geo) <- CRS("+proj=longlat +datum=WGS84")
# specify the bounding box
latLongBox = bbox(benzene_data_geo)
location = c(latLongBox[1, 1] - 0.05,
             latLongBox[2, 1] - 0.05,
             latLongBox[1, 2] + 0.1,
             latLongBox[2, 2] + 0.05)
# create map with location dots marked on it in
MontrelBenzeneMap <-
  get_stamenmap(bbox =  location,
                zoom = 10)
ggmap(MontrelBenzeneMap) + geom_point(data = benzene_data,
                                      aes(x = lon,
                                          y = lat,
                                          size = Benzene),
                                      alpha = 0.45) + theme_void()

```

Using the `geoR` package we can also plot the following:

-  the locations of the sampling sites 
-  the concentrations of ozone in relation to the x and y coordinates
- and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density.

```{r Ex 10.1 geoR plot}
# convert data to utm coordinates
benzene_data_utm <- spTransform(benzene_data_geo,
                        CRS("+proj=utm +zone=18 +ellps=WGS72"))
# Save the utm as a data frame
benzene_utm_df <- as.data.frame(benzene_data_utm)
colnames(benzene_utm_df) <- c("Benzene", "X", "Y")
# Save as geodata to generate the geodata plot
benzene_geodata <- as.geodata(benzene_utm_df,
                          coords.col = 2:3, data.col = 1)
plot(benzene_geodata)
```


## Example 10.2: Examining the log concentrations of benzene in Montreal {-}

```{r Ex 10.2 plot hist and qqplot log}
# Histogram for the log of the benzene concentration
log_histogram <- hist(log(benzene_data$Benzene), main = "", xlab = "log(Benzene)")
# qqplot for the log of the benzene concentration
qqnorm(log(benzene_data$Benzene), bty = "n");
qqline(log(benzene_data$Benzene))

```
<!-- NOTE: I don't know how to generate the plot in Figure 9.4 -->

## Example 10.5: Variogram {-}


```{r Ex 10.5 plot variogram}

library(gstat)
benzene_utm_geo <- benzene_utm_df
# get the coordinates in kms and turn into a Spatial object
benzene_utm_geo[,c("X", "Y")] <- benzene_utm_geo[,c("X", "Y")]/1000
coordinates(benzene_utm_geo) <- ~ X + Y
# Plot the variogram and fit one
benzene_vgm <- variogram(log(Benzene)~ X + Y, data = benzene_utm_geo)
benzene_vgm_fit = fit.variogram(benzene_vgm,
                                model = vgm(0.1, "Exp",6))
benzene_vgm_fit
plot(benzene_vgm, benzene_vgm_fit)
```

## Example 10.6 Basic spatial modelling and prediction of benzene in Montreal {-}


```{r Ex 10.6 kriging predictions, message = "FALSE", warning = "FALSE"}
# Generate grid
MtlPred <- expand.grid(seq (580, 615 , 0.5),
                             seq (5020, 5060 , 0.5) )
# change names grid
names(MtlPred)[ names(MtlPred)=="Var1"] <- "X"
names(MtlPred)[ names(MtlPred)=="Var2"] <- "Y"
# make the grid a Spatial object
coordinates (MtlPred) = ~ X + Y
gridded(MtlPred) = TRUE
# define the model based on the variogram fit from the previous example
mod <- vgm (0.053 , "Exp", 2.159 )
# use ordinary kriging to predict values in the grid
x <- krige(log(Benzene) ~ X + Y, benzene_utm_geo , MtlPred , model = mod )
# Plot the ordinary kriging predictions and their variance
krig_pred <- spplot (x["var1.pred"], main = "Ordinary kriging predictions ")
krig_var <- spplot (x["var1.var"], main = "Ordinary kriging variance ")
plot_grid(krig_pred, krig_var, labels = "auto")

```


## Example 10.9 Spatial modelling of Benzene in Montreal {-}

### Nimble {-}


```{r Ex 10.9 load data, message = FALSE, warning=FALSE, error=FALSE}
library(nimble)
library(geoR)
library(spdep)
```

```{r Ex 10.9 benzene to spatial data, message = FALSE, warning=FALSE, error=FALSE}
# Load data on benzene concentration in Montreal
benzene_data <- read.csv("data/montreal_benzene_apr.csv")
# create a new variable in "sp" format and define coordinates
benzene_data_geo <- benzene_data
coordinates(benzene_data_geo) <- ~ lon + lat
proj4string(benzene_data_geo) <- CRS("+proj=longlat +datum=WGS84")

benzene_data_utm <- spTransform(benzene_data_geo,
                        CRS("+proj=utm +zone=18 +ellps=WGS72"))
# Save the utm as a data frame
benzene_utm_df <- as.data.frame(benzene_data_utm)
# Change coordinates to kilometers and observations to the log scale
Mtl_benzene_sample <-
  data.frame(
    y = log(benzene_utm_df$Benzene),
    easting =  benzene_utm_df$lon / 1000,
    northing = benzene_utm_df$lat / 1000
  )
# Compute the distance matrix
Dist <- as.matrix(dist(Mtl_benzene_sample[,c("easting", "northing")]))

```

```{r Ex 10.9 nimble model}

Example10_9Code <-  nimbleCode ({
  # Covariance matrix spatial effect
  Sigma[1:n, 1:n] <- (sigma^2)*exp(-distMatrix[1:n,1:n]/phi) + (tau^2)*identityMatrix(d = n)
 
   for (site in 1:n) {
    mean.site[site] <- beta0 + beta1*easting[site] + beta2*northing[site]
  }
  y[1:n]  ~  dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n])
  # Set up the priors for the spatial model
  sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
   phi_inv ~ dgamma(shape =  5, rate = 5)
   phi <- 1/phi_inv
  # prior for the coefficients 
    beta0 ~ dnorm (0, 10)
    beta1 ~ dnorm (0, 10)
    beta2 ~ dnorm (0, 10)

}) 

```


Define the constants, data and initials lists for the `nimble` model.



```{r nimble Ex 10.9 set constants and inits, error = FALSE, message = FALSE, results='hide'}
# Define the constants, data, parameters and initial values
constants <-
  list(n = nrow(Mtl_benzene_sample))
ex.data <-
  list(y = Mtl_benzene_sample$y,
       easting = as.vector(scale(Mtl_benzene_sample$easting)),
       northing = as.vector(scale(Mtl_benzene_sample$northing)),
       distMatrix = Dist)
params <- c(  "beta0", "beta1","beta2", "sigma", "phi", "tau")
inits <- list( sigma = 0.1, phi_inv = 6/max(Dist), tau = 0.1)
# Run model in nimble
mcmc.out <- nimbleMCMC(
  code = Example10_9Code,
  constants = constants,
  data = ex.data,
  inits = inits,
  monitors = params,
  niter = 15000,
  nburnin = 7000,
  thin = 14,
  WAIC = TRUE,
  nchains = 2,
  summary = TRUE,
  samplesAsCodaMCMC = TRUE
)

```

```{r Ex 10.9 nimble WAIC, ESS and traceplots }

mcmc.out$WAIC
min(coda::effectiveSize(mcmc.out$samples))
plot(mcmc.out$samples[, c("beta0")], bty = "n")
plot(mcmc.out$samples[, c("beta1")], bty = "n")
plot(mcmc.out$samples[, c("beta2")], bty = "n")
plot(mcmc.out$samples[, c("sigma")], bty = "n")
plot(mcmc.out$samples[, c("tau")], bty = "n")
plot(mcmc.out$samples[, c("phi")], bty = "n")
mcmc.out$summary$all.chains
```

<!-- TODO: Predictions -->

### Stan

```{r load stan, message=FALSE, echo = FALSE, warning=FALSE, message= FALSE}
# load rstan with options
library(geoR)
library(rstan)
library(spdep)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```


```{r stan load data }
benzene_data <- read.csv("data/montreal_benzene_apr.csv")
# create a new variable in "sp" format and define coordinates
benzene_data_geo <- benzene_data
coordinates(benzene_data_geo) <- ~ lon + lat
proj4string(benzene_data_geo) <- CRS("+proj=longlat +datum=WGS84")

benzene_data_utm <- spTransform(benzene_data_geo,
                        CRS("+proj=utm +zone=18 +ellps=WGS72"))
# Save the utm as a data frame
benzene_utm_df <- as.data.frame(benzene_data_utm)
# change the observed values to the log scale and the coordinates to km's
Mtl_benzene_sample <-
  data.frame(
    y = log(benzene_utm_df$Benzene),
    easting =  benzene_utm_df$lon / 1000,
    northing = benzene_utm_df$lat / 1000
  )
# Compute the distance matrix
Dist <- as.matrix(dist(Mtl_benzene_sample[,c("easting", "northing")]))

```



```{r engine='bash', comment='', echo = FALSE}
cat functions/Example10_9.stan
``` 


```{r Ex 10.9 stan exponential model, warning = FALSE}

N <- nrow(benzene_utm_df)
# Change coordinates to kilometers
X <- data.frame(easting = as.vector(scale(Mtl_benzene_sample$easting/1000)),
                northing = as.vector(scale(Mtl_benzene_sample$northing/1000))) 

ex.data <- list(
  N = N,
  p = 2,
  y =   log(benzene_utm_df$Benzene),
  dist_matrix = Dist,
  X = as.matrix(X)
)

Example10_9Stan  <- stan(
  file = "functions/Example10_9.stan",
  data = ex.data,
  warmup = 10000,
  iter = 20000,
  chains = 2,
  thin = 10,
  pars = c("beta0", "beta","sigma", "tau", "phi"),
  include = TRUE
)

```


```{r  Ex 10.9 stan exp traceplots, warning = FALSE}

traceplot(Example10_9Stan, pars = c("beta0","beta","sigma", "tau", "phi"))

```

```{r Ex 10.9 stan exp results}
summary_exp_stan <-
  summary(
    Example10_9Stan,
    pars = c("beta0","beta", "phi", "sigma", "tau"),
    probs = c(0.025, 0.975)
  )

summary_exp_stan$summary

```

<!-- TODO: Predictions -->

## Example 10.11: INLA

```{r}
library(INLA)

benzene_data <- read.csv("data/montreal_benzene_apr.csv")
# create a new variable in "sp" format and define coordinates
benzene_data_geo <- benzene_data[,c("lon", "lat")]
coordinates(benzene_data_geo) <- ~ lon + lat
proj4string(benzene_data_geo) <- CRS("+proj=longlat +datum=WGS84")

benzene_data_utm <- spTransform(benzene_data_geo,
                        CRS("+proj=utm +zone=18 +ellps=WGS72"))
# Save the utm as a data frame
benzene_utm_df <- as.data.frame(benzene_data_utm)
# change the observed values to the log scale and the coordinates to km's

mesh = inla.mesh.create(benzene_data_geo, cutoff = 0.001) 
plot(mesh , col="gray", main="") 


ukmap <- readShapeLines("uk_BNG.shp") plot(mesh , col="gray", main="") 
lines(ukmap)
points(locations , col="red", pch=20,bg="red") 


```

## Example 10.13: Directional variograms

```{r Ex 10.13 directional variogram, error = FALSE, message = FALSE, results='hide'}
### Compute and plot the directional variogram
CA.geo <- as.geodata( benzene_utm_df , coords.col = 2:3 , data.col=1)
CA.vario4 <- variog4(CA.geo )
plot(CA.vario4)
```







[["Time.html", "Chapter 11 Time-why it also matters Example 11.1 Ground level ozone concentrations Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average Example 11.13 Forecasting ozone levels Example 11.14 Forecasting volcanic ash Example 11.16 implementation of a dynamic linear model", " Chapter 11 Time-why it also matters The chapter contains the theory required for handling time series data. From this chapter, the reader will have gained an understanding of the following topics: That a temporal process consists of both low and high frequency components, the former playing a key role in determining long-term trends while the latter may be associated with shorter-term changes. Techniques for the exploratory analysis of the data generated by the temporal process, including the ACF (correlogram) and PACF (periodogram). Models for irregular (high frequency) components after the regular components (trend) have been removed. Methods for forecasting, including exponential smoothing and ARIMA modelling. The state space modelling approach, which sits naturally within a Bayesian setting and which provides a general framework for most of the classical time series models and many more besides. Implementing time series processes within a Bayesian hierarchical framework. Example 11.1 Ground level ozone concentrations Load the daily and hourly data for one site. library(ggplot2) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # change the format of the date column site_daily$date &lt;- as.Date(site_daily$date, &quot;%m/%d/%Y&quot;) # load hourly data from that same site site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Plot the daily and hourly time series. # Plot daily data ggplot(data = site_daily) + geom_line(aes(x = date, y = max.ozone, group = 1)) + # draw a line at the first data geom_vline(xintercept = as.Date(&quot;2013-01-01&quot;), color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm) geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + theme_clear() # Plot hourly data ggplot(data = site_hourly,) + geom_line(aes(x = time, y = ozone, group = 1)) + geom_vline(xintercept = 1, color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm). geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Hour in 2013&#39;s ozone season&quot;) + ylab(&quot;Hourly Ozone Concentration (ppm)&quot;) + theme_clear() Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average For this example we will use the TTR package (Technical Trading Rules). This allow us to manipulate objects like time series for forecasting. library(TTR) # Load daily data site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # add an identifier column for each day in the sample site_daily$day &lt;- 1:nrow(site_daily) # add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } # Add loess smooth # Single day ozone.loess &lt;- loess(max.ozone ~ day, span = 0.75, data = site_daily[,c(&quot;max.ozone&quot;, &quot;day&quot;)]) ozone.predict &lt;- predict(ozone.loess, data.frame(day = 1:nrow(site_daily))) ozone.predict_df &lt;- data.frame(day = 1:nrow(site_daily), ozone.prediction = ozone.predict) ggplot(data = site_daily) + geom_line(aes(x = day, y = max.ozone, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Single day&quot;) + theme_clear() # Three days ozone_SMA3 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 3), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA3) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Three days&quot;) + theme_clear() # Six days ozone_SMA6 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 6), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA6) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Six days&quot;) + theme_clear() # Twelve days ozone_SMA12 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 12), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA12) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Twelve days&quot;) + theme_clear() Example 11.13 Forecasting ozone levels library(TTR) library(forecast) # Load hourly data for site 060379033 site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # one night hour per day missing for instrument calibration - imputed for simplicity imputeNA &lt;- mean(site_hourly$ozone, na.rm = TRUE) site_hourly$ozone[is.na(site_hourly$ozone)] &lt;- imputeNA # Select the first seven days in july # days_pattern contains the dates for the first seven days days_pattern &lt;- paste0(&quot;^2013070&quot;, 1:7, collapse=&quot;|&quot;) # select all the rows that follow that pattern using grepl july_seven_days &lt;- site_hourly[grepl(days_pattern, site_hourly$datetime),] july_seven_days$hours &lt;- 1:nrow(july_seven_days) # Holt-Winters model fitting # Turn this into a time series object to use Holt-Winters forecast level_ts &lt;- ts(july_seven_days$ozone, frequency = 24, start = c(1)) ozone_forecast &lt;- HoltWinters(level_ts) # Plot using the default function plot( ozone_forecast, xlab = &quot;Hours - First Week -July 2013&quot;, ylab = &quot;O3 (ppm)&quot;, col.predicted = 1, col = &quot;black&quot;, bty = &quot;n&quot;, lty = 2 ) # Holt- Winters 24 ahead forast on Day 8 # no need to specify Holt-Winters forecast as the object is already HoltWinters class ozoneforecast_day8 &lt;- forecast(ozone_forecast, h=24) # Plot using default function plot(ozoneforecast_day8, bty = &quot;n&quot;) Example 11.14 Forecasting volcanic ash The data in this example consists of atmospheric levels of volcanic ash from 1500AD to 2000AD. library(ggplot2) library(forecast) library(TTR) # Load volcano dust data ## REVIEW: Data source: Hyn�d�man, R.J. Time Series Data Library, http://data.is/TSDLdemo # Data cover the period from 1500AD to 2000AD volcano_dust &lt;- scan(&quot;https://robjhyndman.com/tsdldata/annual/dvi.dat&quot;, skip = 1) # Add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } The following figure shows the plot of the original time series. # Turn data into data frame to plot it in ggplot volcano_dust_df &lt;- data.frame(year = 1500:(1500+length(volcano_dust)-1), dust = volcano_dust) ggplot(data = volcano_dust_df) + geom_line(aes(x = year, y = dust, group = 1)) + xlab(&quot;Year&quot;) + ylab(&quot;Atmospheric levels of volcanic ash&quot;) + theme_clear() We can also plot the autocorrelogram (ACF) and partial autocorrelogram (PACF) to identify any autocorrelation in the time series. # convert data into a time series object volcano_dust_series &lt;- ts(volcano_dust, start = c(1500)) # Compute autocorrelogram with max lag 20 acf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Autocorrelogram volcano dust&quot; ) # Compute the partial autocorrelogram with max lag 20 pacf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Partial autocorrelogram volcano dust&quot; ) # Finding an ARIMA model auto.arima(volcano_dust_series, ic = &quot;aic&quot;) ## Series: volcano_dust_series ## ARIMA(1,0,2) with non-zero mean ## ## Coefficients: ## ar1 ma1 ma2 mean ## 0.4723 0.2694 0.1279 57.5178 ## s.e. 0.0936 0.0969 0.0752 8.4883 ## ## sigma^2 = 4897: log likelihood = -2661.84 ## AIC=5333.68 AICc=5333.81 BIC=5354.45 # fitting the ARIMA(2,0,0) model volcano_dust_arima &lt;- arima(volcano_dust_series, order = c(2, 0, 0)) # forecast 31 years with the ARIMA(2,0,0) model volcano_dust_forecast &lt;- forecast(volcano_dust_arima, h = 31) plot(volcano_dust_forecast, bty = &quot;n&quot;) Example 11.16 implementation of a dynamic linear model Autoregressive model daily data Stan library(coda) library(ggplot2) library(rstan) options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } // Autoregressive model data { int&lt;lower=0&gt; N; vector[N] y; real m0; real&lt;lower=0&gt; C0; } parameters { real beta; real&lt;lower=0&gt; sigma; // standard deviation real theta0; vector[N] theta; real&lt;lower=0&gt; W; } model { beta ~ uniform(-1, 1); theta0 ~ normal(m0, C0); theta[1] ~ normal(theta0, W); for (n in 2:N){ theta[n] ~ normal(theta[n-1], W); y[n] ~ normal(theta[n] + beta * y[n-1], sigma); } } generated quantities{ vector[N] log_lik; vector[N] yfit; yfit[1] = y[1]; for (n in 2:N){ log_lik[n] = normal_lpdf(y[n] | theta[n-1] + beta * y[n-1], sigma); yfit[n] = normal_rng (theta[n-1] + beta * yfit[n-1], sigma); } } # fit a linear growth model for the daily data yt &lt;- site_daily$max.ozone N &lt;- length(yt) ex.data &lt;- list( N = length(yt), y = yt, m0 = mean(yt), C0 = 10 ) # Run the model in Stan Ex11_16StanAR &lt;- stan( file = &quot;functions/AR_Model.stan&quot;, data = ex.data, chains = 3, iter = 10000, warmup = 3000, thin = 14, # QUESTION: should we explain this? control = list(adapt_delta = 0.8, max_treedepth = 15), init = &quot;random&quot;, pars = c( &quot;beta&quot;, &quot;sigma&quot;, &quot;theta&quot;,&quot;W&quot;, &quot;theta0&quot;, &quot;yfit&quot;), include = TRUE ) # traceplots of parameters a and b rstan::traceplot(Ex11_16StanAR, pars = c(&quot;beta&quot;, &quot;W&quot;,&quot;sigma&quot;)) # traceplots of some fitted values rstan::traceplot(Ex11_16StanAR, pars = c(&quot;theta[2]&quot;, &quot;theta[50]&quot;, &quot;theta[100]&quot;, &quot;theta[150]&quot;, &quot;theta[250]&quot;, &quot;theta[350]&quot;), nrow = 2) summary_fit &lt;- summary(Ex11_16StanAR, pars = c( &quot;beta&quot;, &quot;sigma&quot;, &quot;W&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_fit ## mean se_mean sd 5% 95% n_eff ## beta 0.4017129423 2.113331e-03 0.0572023591 0.3098660782 0.491077041 732.6438 ## sigma 0.0090242537 9.776237e-06 0.0003551437 0.0084567025 0.009608952 1319.6684 ## W 0.0009587905 1.298206e-05 0.0002285123 0.0006246792 0.001382478 309.8359 ## Rhat ## beta 0.9991595 ## sigma 1.0038715 ## W 1.0013533 Plot fitted values # Posterior summary of state vector summary_theta &lt;- summary(Ex11_16StanAR, pars = c(&quot;theta&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_theta$time &lt;- 1:length(yt) # Plot mean and 95% CIs for the state vector ggplot(summary_theta) + geom_ribbon(aes(x = time, ymin = `5%` , ymax = `95%`), alpha = 0.5, fill = &quot;lightgray&quot;,) + geom_path(aes(x = time, y = mean), colour = &quot;blue&quot;, size = 0.8) + theme_clear() + ggtitle(&quot;State vector&quot;) # Posterior summary of fitted values summary_fit &lt;- summary(Ex11_16StanAR, pars = c(&quot;yfit&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_fit$real &lt;- yt summary_fit$time &lt;- 1:length(yt) # Plot mean and 95% CIs for the fitted values ggplot(summary_fit) + geom_ribbon(aes(x = time, ymin = `5%` , ymax = `95%`), alpha = 0.5, fill = &quot;lightgrey&quot;)+ geom_path(aes(x = time, y = mean), colour = &quot;blue&quot;, size = 0.8) + geom_point(aes(x = time, y = real)) + theme_clear() + ggtitle(&quot;Fitted values&quot;) Nimble library(coda) library(nimble) library(ggplot2) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Example11_16Nimble &lt;- nimbleCode ({ theta0 ~ dnorm(m0, var = C0) theta[1] ~ dnorm(theta0, sd = W) for (i in 2:Tt) { theta[i] ~ dnorm(theta[i-1], sd = W) mu[i] &lt;- theta[i] + beta * y[i-1] y[i] ~ dnorm(mu[i], sd = sigma) } # Priors sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) W ~ T(dt(mu = 0, sigma = 1, df = 0.01), 0, Inf) # prior for the intercept term beta ~ dnorm (0, sd = 10) # fitted values yfit[1] &lt;- y[1] for (j in 2:Tt){ mufit[j] &lt;- theta[j] + beta * yfit[j-1] yfit[j] ~ dnorm(mufit[j], sd = sigma) } }) Run model in nimble # constants list constants &lt;- list( Tt = length(site_daily$max.ozone), m0 = mean(site_daily$max.ozone), C0 = 10 ) # data list ex.data &lt;- list( y = site_daily$max.ozone) # vector of covariates inits &lt;- list( beta = rnorm(1), sigma = 1, W = 0.001 ) # Run model in nimble ARModel &lt;- nimbleModel(code = Example11_16Nimble, data = ex.data, constants = constants, inits = inits, check = FALSE) C_ARModel &lt;- compileNimble(ARModel) AR_mcmcConfig &lt;- configureMCMC(ARModel, enableWAIC = TRUE) AR_mcmcConfig$addMonitors(&quot;beta&quot;, &quot;sigma&quot;, &quot;W&quot;, &quot;theta&quot;, &quot;yfit&quot;) AR_mcmcConfig$removeSamplers(c(&#39;theta&#39;)) AR_mcmcConfig$addSampler(target = c(&#39;theta&#39;), type = &#39;AF_slice&#39;) AR_mcmc &lt;- buildMCMC(AR_mcmcConfig) C_AR_mcmc &lt;- compileNimble(AR_mcmc, project = ARModel) mcmc.out &lt;- runMCMC( C_AR_mcmc, niter = 60000, nburnin = 24000, thin = 40, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) mcmc.out$WAIC min(coda::effectiveSize(mcmc.out$samples)) plot(mcmc.out$samples[, c(&quot;beta&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;sigma&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;W&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;theta[10]&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;theta[100]&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;theta[150]&quot;)], bty = &quot;n&quot;) variables &lt;- c(&quot;beta&quot;, &quot;sigma&quot;, &quot;W&quot;) summary_AR_nimble &lt;- mcmc.out$summary$all.chains summary_AR_nimble[variables,] Plot fitted values and state vector # Posterior summary of fitted values fitted_AR_nimble &lt;- summary_AR_nimble[grepl(&quot;yfit\\\\[&quot;, rownames(summary_AR_nimble)),] |&gt; as.data.frame() fitted_AR_nimble$real &lt;- site_daily$max.ozone fitted_AR_nimble$time &lt;- 1:length(site_daily$max.ozone) # Plot mean and 95% CIs for the fitted values ggplot(fitted_AR_nimble) + geom_ribbon(aes(x = time, ymin = `95%CI_low` , ymax = `95%CI_upp`), alpha = 0.5, fill = &quot;lightgrey&quot;)+ geom_path(aes(x = time, y = Mean), colour = &quot;blue&quot;, size = 0.8) + geom_point(aes(x = time, y = real)) + theme_clear() + ggtitle(&quot;Fitted values&quot;) # Posterior summary of the state vector theta_AR_nimble &lt;- summary_AR_nimble[grepl(&quot;theta\\\\[&quot;, rownames(summary_AR_nimble)),] |&gt; as.data.frame() theta_AR_nimble$time &lt;- 1:length(site_daily$max.ozone) # Plot mean and 95% CIs for the state vector ggplot(theta_AR_nimble) + geom_ribbon(aes(x = time, ymin = `95%CI_low` , ymax = `95%CI_upp`), alpha = 0.5, fill = &quot;lightgrey&quot;)+ geom_path(aes(x = time, y = Mean), colour = &quot;blue&quot;, size = 0.8) + theme_clear() + ggtitle(&quot;State vector&quot;) UK ozone data RW library(ggplot2) library(rstan) # Stan options for multiple cores options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load ozone UK data uk_ozone &lt;- read.csv(&quot;data/uk_ozone_one_site.csv&quot;) # change the format of the date column uk_ozone$date &lt;- as.Date(uk_ozone$date, &quot;%Y-%m-%d&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Plot the UK ozone data # TODO: change y label for ozone concentration? ggplot(uk_ozone) + geom_path(aes(x = date, y = ozone), colour = &quot;dimgray&quot;) + theme_clear() # convert data into a time series object uk_ozone_ts &lt;- ts(uk_ozone$ozone) # Compute autocorrelogram with max lag 20 acf( uk_ozone_ts, lag.max = 30, bty = &quot;n&quot;, main = &quot;Autocorrelogram UK ozone&quot; ) # Compute the partial autocorrelogram with max lag 20 pacf( uk_ozone_ts, lag.max = 30, bty = &quot;n&quot;, main = &quot;Partial autocorrelogram UK ozone&quot; ) # fit a varying mean model for the daily data ex.data &lt;- list( N = length(uk_ozone$ozone), y = uk_ozone$ozone, p = 2, X = as.data.frame(scale(uk_ozone[,c(&quot;temp&quot;, &quot;wind&quot;)])), m0 = mean(uk_ozone$ozone), C0 = 10 ) # Run the model in Stan Ex11_16StanRW &lt;- stan( file = &quot;functions/RW_Model.stan&quot;, data = ex.data, chains = 3, iter = 30000, warmup = 9000, thin = 14, control = list(adapt_delta = 0.8, max_treedepth = 15), init = &quot;random&quot;, pars = c( &quot;beta&quot;, &quot;sigma&quot;, &quot;theta&quot;,&quot;theta0&quot;,&quot;W&quot;, &quot;yfit&quot;), include = TRUE ) ## Warning: There were 3 chains where the estimated Bayesian Fraction of Missing Information was low. See ## https://mc-stan.org/misc/warnings.html#bfmi-low ## Warning: Examine the pairs() plot to diagnose sampling problems Show trace plots for some of the parameters. # traceplots of parameters a and b traceplot(Ex11_16StanRW, pars = c(&quot;beta&quot;, &quot;sigma&quot;, &quot;W&quot;)) # traceplots of parameter theta traceplot(Ex11_16StanRW, pars = c(&quot;theta[1]&quot;, &quot;theta[2]&quot;, &quot;theta[3]&quot;)) summary_fit &lt;- summary(Ex11_16StanRW, pars = c( &quot;beta&quot;, &quot;sigma&quot;, &quot;W&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_fit ## mean se_mean sd 5% 95% n_eff Rhat ## beta[1] -2.973573 0.02138897 1.2961483 -5.155536 -0.8370396 3672.2282 1.0009607 ## beta[2] 2.534846 0.01016869 0.6463828 1.470742 3.5957600 4040.6339 1.0001834 ## sigma 8.556388 0.01343272 0.5614383 7.632489 9.4762255 1746.9331 0.9995143 ## W 2.547188 0.02428486 0.7494389 1.389917 3.8454391 952.3606 0.9997619 Plot the state vector and the fitted values. summary_theta &lt;- summary(Ex11_16StanRW, pars = c(&quot;theta&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_theta$time &lt;- 1:nrow(summary_theta) ggplot(summary_theta) + geom_ribbon(aes(x = time, ymin = `5%`, ymax = `95%`), alpha = 0.5, fill = &quot;lightgrey&quot;) + geom_line(aes(x = time, y = mean), colour = &quot;blue&quot;, size = 0.8) + theme_clear() + ggtitle(&quot;State vector&quot;) summary_fitted &lt;- summary(Ex11_16StanRW, pars = c(&quot;yfit&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() summary_fitted$real &lt;- uk_ozone$ozone summary_fitted$time &lt;- 1:nrow(uk_ozone) # Plot mean and 95% CIs for the fitted values ggplot(summary_fitted) + geom_ribbon(aes(x = time, ymin = `5%` , ymax = `95%`), alpha = 0.5, fill = &quot;lightgrey&quot;) + geom_path(aes(x = time, y = mean), colour = &quot;blue&quot;, size = 0.8) + geom_point(aes(x = time, y = real)) + theme_clear() + ggtitle(&quot;Fitted values&quot;) UK ozone data linear growth library(ggplot2) library(rstan) # Stan options for multiple cores options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load ozone UK data uk_ozone &lt;- read.csv(&quot;data/uk_ozone_one_site.csv&quot;) # change the format of the date column uk_ozone$date &lt;- as.Date(uk_ozone$date, &quot;%Y-%m-%d&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } # fit a varying mean model for the daily data q &lt;- 3 N &lt;- length(uk_ozone$ozone) FF &lt;- matrix(0, nrow = N, ncol = q) FF[1:N,1] &lt;- 1 FF[,2] &lt;- as.vector(scale(uk_ozone$temp)) FF[,3] &lt;- as.vector(scale(uk_ozone$wind)) ex.data &lt;- list( N = N, y = uk_ozone$ozone, q = q, FF = FF, GG = diag(q), m0 = c(mean(uk_ozone$ozone),0, 0), C0 = diag(c(1,1, 1)) ) # Run the model in Stan Ex11_16Stan &lt;- stan( file = &quot;functions/DLM.stan&quot;, data = ex.data, chains = 2, iter = 10000, warmup = 4000, thin = 14, control = list(adapt_delta = 0.8, max_treedepth = 15), init = &quot;random&quot;, pars = c( &quot;sigma&quot;, &quot;theta&quot;,&quot;theta0&quot;,&quot;W&quot;, &quot;yfit&quot;), include = TRUE ) Show trace plots for some of the parameters. # traceplots of parameters a and b traceplot(Ex11_16Stan, pars = c( &quot;sigma&quot;, &quot;W&quot;)) # traceplots of parameter theta traceplot(Ex11_16Stan, pars = c(&quot;theta[1,1]&quot;, &quot;theta[2,1]&quot;, &quot;theta[3,1]&quot;, &quot;theta[1,100]&quot;, &quot;theta[2,100]&quot;, &quot;theta[3,100]&quot;), nrow = 2) # Extract samples summary_RW_stan &lt;- summary( Ex11_16Stan, pars = c( &quot;sigma&quot;,&quot;W&quot;), probs = c(0.025, 0.975) ) summary_RW_stan "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

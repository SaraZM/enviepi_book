[["index.html", "Spatio-temporal methods in environmental epidemiology Introduction", " Spatio-temporal methods in environmental epidemiology Gavin Shaddick, James V. Zidek, and Alexandra M. Schmidt 2023-03-01 Introduction This is the online companion for the book Spatio-temporal methods in environmental epidemiology published in Chapman and Hall/CRC. All the codes used for the examples in the book are presented here to ensure the material is reproducible, transparent, and accessible. Please feel free to contact us if you find any typos, or error in our code Errare humanum est. We would like to thank Yang ‘Seagle’ Liu, Yiping Dou, and Yi Liu for allowing us to include their code and other material in the book and in the online resources. We would also like to thank Johnny Xi, Paritosh Kumar Roy and Sara Zapata-Marin for their help developing some of the additional examples and exercises for this edition. "],["preface-2nd-edition.html", "Preface (2nd edition)", " Preface (2nd edition) Spatio-Temporal Methods in Environmental Epidemiology using R is the first book of its kind to specifically address the interface between environmental epidemiology and spatio-temporal modeling. In response to the growing need for collaboration between statisticians and environmental epidemiologists, the book links recent developments in spatio-temporal methodology with epidemiological applications. Drawing on real-life problems, it provides the tools required to exploit advances in methodology when assessing the health risks associated with environmental hazards. Clear guidelines are given to enable the implementation of methodology and estimation of risks in practice. Designed for graduate students in both epidemiology and statistics, the text covers a wide range of topics, from an introduction to epidemiological principles and the foundations of spatio-temporal modeling to new directions for research. It describes traditional and Bayesian approaches and presents the theory of spatial, temporal, and spatio-temporal modeling in the context of its application to environmental epidemiology. The text includes practical examples together with embedded R code and details of specific R packages and the use of other software including Nimble, Stan, and INLA. Online resources associated with the book provide additional code, data, examples, exercises, lab projects, and more. Representing a major new direction in environmental epidemiology, this book—in full color throughout—underscores the increasing need to consider dependencies in both space and time when modeling epidemiological data. Students will learn how to identify and model patterns in spatio-temporal data and to exploit dependencies over both space and time in order to reduce bias and inefficiency. From this book the reader will have gained an understanding of the following topics: The basic concepts of epidemiology and the estimation of risks associated with environmental hazards. Hierarchical modelling with a Bayesian framework. The theory of spatial, temporal and spatio–temporal process needed for environmental health risk analysis. Fundamental questions related to the nature and role of uncertainty in environmental epidemiology and methods which may help answer those questions. Important areas of application within environmental epidemiology together with strategies for building the models that are needed and coping with challenges that arise. Methods and software for the analysis and visualisation of environmental and health. - Examples of R and WinBUGS code are given throughout the book and, together with data for the examples the code, are included in the online resources. Offer a variety of exercises, both theoretical and practical, to assist in the development of the skills needed to perform spatio–temporal analyses. New frontiers and areas of current and future research. "],["why.html", "Chapter 1 Why spatio-temporal epidemiology? Example 1.5", " Chapter 1 Why spatio-temporal epidemiology? This chapter provides a overview of methods for spatio-temporal modelling and their use in epidemiological studies Example 1.5 # Loading relevant libraries library(ggmap) library(sp) library(rgdal) # Load Meuse river data(meuse) # Assign a reference system used in the Netherlands coordinates(meuse) &lt;- ~ x + y proj4string(meuse) &lt;- CRS(&#39;+init=epsg:28992&#39;) # Convert it to latitude - longitude scale meuse_ll &lt;- spTransform(meuse,CRS(&quot;+proj=longlat +datum=WGS84&quot;)) ## Warning: PROJ support is provided by the sf and terra packages among others meuse_ll_df &lt;- as.data.frame(meuse_ll) # Specify the bounding box latLongBox = bbox(meuse_ll) location = c(latLongBox[1, 1] - 0.01, latLongBox[2, 1] - 0.01, latLongBox[1, 2] + 0.01, latLongBox[2, 2] + 0.01) # Create map with location dots marked on it in MeuseMap &lt;- get_stamenmap( bbox = location, zoom = 14 ) ## ℹ Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL. ggmap(MeuseMap) + geom_point( data = meuse_ll_df, aes( x = x, y = y, color = &quot;red&quot; )) + theme_void() + theme(legend.position=&quot;none&quot;) # Finally we write the result that can be read by Google maps writeOGR(meuse_ll, &quot;meuse.kml&quot;, &quot;meuse&quot;, driver=&quot;KML&quot;) "],["basics.html", "Chapter 2 Epidemiology-the basics Example 2.9: Estimating the SMR using a Poisson GLM Example 2.10: Estimating the SMR using quasi-likelihood Example 2.11: Modelling differences in SMRs in relation to differences in exposures Example 2.12: Modelling the risks associated with lagged effects of air pollution Example 2.13: Estimating the odds ratio in a case-control study using a logistic model Example 2.14: Estimating the odds ratio of asthma associated with proximity to roads", " Chapter 2 Epidemiology-the basics This chapter contains the basic principles of epidemiological analysis and how estimates of the risks associated with exposures can be obtained. From this chapter, the reader will have gained an understanding of the following topics: Methods for expressing risk and their use with different types of epidemiological study. Calculating risks based on calculations of the expected number of health counts in an area, allowing for the age–sex structure of the underlying population. The use of generalised linear models (GLMS) to model counts of disease and case–control indicators. Modelling the effect of exposures on health and allowing for the possible effects of covariates. Cumulative exposures to environmental hazards. Example 2.9: Estimating the SMR using a Poisson GLM # Finding MLE and SE of log(SMR) = beta0 on one single area y &lt;- 29 # Total observed death E &lt;- 19.88 # Expected deaths summary(glm(y ~ offset(log(E)), family = &quot;poisson&quot;)) ## ## Call: ## glm(formula = y ~ offset(log(E)), family = &quot;poisson&quot;) ## ## Deviance Residuals: ## [1] 0 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.3776 0.1857 2.033 0.042 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 6.6613e-16 on 0 degrees of freedom ## Residual deviance: 4.4409e-15 on 0 degrees of freedom ## AIC: 7.2109 ## ## Number of Fisher Scoring iterations: 3 # Finding MLE and SE of log(SMR) = beta0 over multiple areas summary(glm(Y ~ offset(log(E)),family=&quot;poisson&quot;, data=data)) Example 2.10: Estimating the SMR using quasi-likelihood # Using quasi-likelihood to find the MLE and standard error of log(SMR) = beta0 summary(glm(y ~ offset(log(E)), family=&quot;quasipoisson&quot;), data = data) Example 2.11: Modelling differences in SMRs in relation to differences in exposures # Fitting a model to estimate the relative risk associated with air pollution summary(glm(Y ~ offset(log(E)) + X1, family=&quot;poisson&quot;, data=data)) # Fitting a model to estimate the relative risk associated with air pollution # using a Quasi-Poisson approach summary(glm(Y ~ offset(log(E)) + X1, family = &quot;quasipoisson&quot;, data = data)) #Fitting a Poisson GLM with air pollution and deprivation summary(glm(Y ~ offset(log(E)) + X1 + X2, family = &quot;poisson&quot;, data = data)) # Fitting a Quasi-Poisson GLM with air pollution and deprivation summary(glm(Y ~ offset(log(E)) + X1 + X2, family = &quot;quasipoisson&quot;, data = data)) Perform tests between the deviances of two models. # Test 1: Effect on Quasi-Poisson models with and without deprivation anova( glm(Y ~ offset(log(E)) + X1, family = &quot;quasipoisson&quot;, data = data), # Model 1 glm(Y ~ offset(log(E)) + X1 + X2, family = &quot;quasipoisson&quot;, data = data), # Model2 test = &quot;Chisq&quot; ) # Chi-Squared test # Test 2: Effect on Quasi-Poisson models with and without air pollution anova( glm(Y ~ offset(log(E)) + X1 + X2, family = &quot;quasipoisson&quot;, data = data), # Model 1 glm(Y ~ offset(log(E)) + X2, family = &quot;quasipoisson&quot;, data = data), # Model 2 test = &quot;Chisq&quot; ) # Chi-Squared test Example 2.12: Modelling the risks associated with lagged effects of air pollution # Fitting quasi-poisson model glm( formula = Y ~ offset(log(E)) + X1 + X1t1 + X1t2, family = &quot;quasipoisson&quot;, data = data ) Example 2.13: Estimating the odds ratio in a case-control study using a logistic model # Fitting Odds Ratio glm(formula = Y ~ 1, family = &quot;binomial&quot;, data = data) Example 2.14: Estimating the odds ratio of asthma associated with proximity to roads # Fitting Odds Ratio glm(Y ~ X, family = &quot;binomial&quot;, data = data) "],["uncertainty.html", "Chapter 3 Uncertainty and its reduction", " Chapter 3 Uncertainty and its reduction This chapter contains a discussion of uncertainty, both in terms of statistical modelling and quantification but also in the wider setting of sources of uncertainty outside those normally encountered in statistics. From this chapter, the reader will have gained an understanding of the following topics: Uncertainty can be dichotomised as either qualitative or quantitative, with the former allowing consideration of a wide variety of sources of uncertainty that would be difficult, if not impossible, to quantify mathematically. Quantitative uncertainty can be thought of as comprising both aleatory and epistemic components, the former representing stochastic uncertainty and the latter subjective uncertainty. Methods for assessing uncertainty including eliciting prior information from experts and sensitivity analysis. Indexing quantitative uncertainty using the variance and entropy of the distribution of a random quantity. Uncertainty in post-normal science derives from a wide variety of issues and can lead to high levels of that uncertainty with serious consequences. Understanding uncertainty is therefore a vital feature of modern environmental epidemiology. "],["data.html", "Chapter 4 Data: increasing information and reducing uncertainty", " Chapter 4 Data: increasing information and reducing uncertainty This is a new chapter "],["embracing.html", "Chapter 5 Embracing uncertainty: the Bayesian approach", " Chapter 5 Embracing uncertainty: the Bayesian approach This chapter introduces the Bayesian approach which provides a natural framework for dealing with uncertainty and also for fitting the models that will be encountered later in the book. From this chapter, the reader will have gained an understanding of the following topics: The use of prior distributions to capture beliefs before data are observed. The combination of prior beliefs and information from data to obtain posterior beliefs. The manipulation of prior distributions with likelihoods to formulate posterior distributions and why conjugate priors are useful in this regard. The difference between informative and non-informative priors. The use of the posterior distribution for inference and methods for calculating summary measures. "],["tactics.html", "Chapter 6 Tactics-implementing uncertainty models Example 6.2: Chronic obstructive pulmonary disease (COPD) in England Example 6.3: Fitting a Poisson regression model in Nimble", " Chapter 6 Tactics-implementing uncertainty models This chapter describes methods for implementing Bayesian models when their complexity means that simple, analytic solutions may not be available. From this chapter, the reader will have gained an understanding of the following topics: Analytical approximations to the posterior distribution. Using samples from a posterior distribution for inference and Monte Carlo integration. Methods for direct sampling such as importance and rejection sampling. Markov Chain Monte Carlo (MCMC) and methods for obtaining samples from the required posterior distribution including Metropolis–Hastings and Gibbs algorithms. Using nimble and stan to fit Bayesian models using Gibbs sampling. Integrated Nested Laplace Approximations (INLA) as a method for performing efficient Bayesian inference including the use of R–INLA to implement a wide variety of latent process models. Example 6.2: Chronic obstructive pulmonary disease (COPD) in England We now look at example into the hospital admission rates for chronic obstructive pulmonary disease (COPD) in England between 2001–2010. In England, there are 324 local authority administrative areas each with an observed and expected number of cases. The expected numbers were calculated using indirect standardization by applying the age–sex specific rates for the whole of England to the age–sex population profile of each of the areas. For this example, the following packages are needed ggplot2 and sf. Load the necessary packages. library(ggplot2) library(sf) To create SMR maps, we need to read in the relevant shapefiles. englandlocalauthority.shp and englandlocalauthority.dbf contain the location, shape, and attributes of English local authorities. The function read_sf() from the sf package will read these shapefiles into R. copdmortalityobserved.csv contains the observed number of hospital admissions in England by local authority. copdmortalityexpected.csv contains the expected number of hospital admissions in England by local authority. # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) Print summaries of the observed and expected counts. # Printing first six rows of the observed counts head(observed) ## name Y2001 Y2002 Y2003 Y2004 Y2005 Y2006 Y2007 Y2008 ## 00AA City of London LB 2 0 3 1 1 1 5 1 ## 00AB Barking and Dagenham LB 100 100 122 93 136 97 91 96 ## 00AC Barnet LB 110 102 106 89 99 97 72 84 ## 00AD Bexley LB 109 113 113 96 113 97 94 89 ## 00AE Brent LB 69 89 70 59 61 48 53 46 ## 00AF Bromley LB 120 129 135 124 128 117 120 106 ## Y2009 Y2010 ## 00AA 0 1 ## 00AB 101 78 ## 00AC 78 89 ## 00AD 93 93 ## 00AE 55 43 ## 00AF 107 113 # Printing first six rows of the expected counts head(expected) ## E2001 E2002 E2003 E2004 E2005 E2006 ## 00AA 2.648915 2.68106 2.727112 2.749562 2.808655 2.915977 ## 00AB 63.946730 63.41700 62.567863 61.444884 60.677119 59.678672 ## 00AC 121.795213 121.91534 122.451050 123.201898 124.449563 125.982868 ## 00AD 90.201336 91.24645 91.949050 92.754781 93.674540 94.598593 ## 00AE 76.876437 77.18529 78.017980 78.967493 80.422828 81.785325 ## 00AF 131.182934 132.30521 133.257442 134.520920 136.441229 137.382528 ## E2007 E2008 E2009 E2010 ## 00AA 3.021586 3.114696 3.237998 3.237998 ## 00AB 58.487583 57.701932 57.250524 57.250524 ## 00AC 127.088805 128.825149 131.374946 131.374946 ## 00AD 95.447131 96.832061 97.651369 97.651369 ## 00AE 83.651266 85.265264 87.089119 87.089119 ## 00AF 138.634021 139.508507 140.634084 140.634084 # Summarising the observed counts summary(observed) ## name Y2001 Y2002 Y2003 ## Length:324 Min. : 2.00 Min. : 0.00 Min. : 3.00 ## Class :character 1st Qu.: 35.00 1st Qu.: 38.00 1st Qu.: 38.00 ## Mode :character Median : 50.00 Median : 52.00 Median : 52.00 ## Mean : 68.01 Mean : 69.63 Mean : 73.44 ## 3rd Qu.: 83.50 3rd Qu.: 80.75 3rd Qu.: 83.25 ## Max. :445.00 Max. :438.00 Max. :480.00 ## Y2004 Y2005 Y2006 Y2007 ## Min. : 1.00 Min. : 1.00 Min. : 1.00 Min. : 5.00 ## 1st Qu.: 35.00 1st Qu.: 37.00 1st Qu.: 35.00 1st Qu.: 37.00 ## Median : 49.50 Median : 51.00 Median : 49.00 Median : 50.00 ## Mean : 66.67 Mean : 69.37 Mean : 67.07 Mean : 68.17 ## 3rd Qu.: 81.25 3rd Qu.: 80.50 3rd Qu.: 81.00 3rd Qu.: 79.00 ## Max. :428.00 Max. :395.00 Max. :428.00 Max. :456.00 ## Y2008 Y2009 Y2010 ## Min. : 1.00 Min. : 0.00 Min. : 1.00 ## 1st Qu.: 37.00 1st Qu.: 36.00 1st Qu.: 38.00 ## Median : 51.00 Median : 50.00 Median : 51.00 ## Mean : 71.40 Mean : 67.04 Mean : 68.81 ## 3rd Qu.: 84.25 3rd Qu.: 78.00 3rd Qu.: 81.25 ## Max. :463.00 Max. :394.00 Max. :441.00 # Summarising the expected counts summary(expected) ## E2001 E2002 E2003 E2004 ## Min. : 2.649 Min. : 2.681 Min. : 2.727 Min. : 2.75 ## 1st Qu.: 39.066 1st Qu.: 39.456 1st Qu.: 39.849 1st Qu.: 40.60 ## Median : 51.766 Median : 52.671 Median : 53.487 Median : 54.29 ## Mean : 62.944 Mean : 63.589 Mean : 64.139 Mean : 64.72 ## 3rd Qu.: 74.292 3rd Qu.: 74.974 3rd Qu.: 74.701 3rd Qu.: 74.02 ## Max. :370.913 Max. :371.271 Max. :369.861 Max. :368.87 ## E2005 E2006 E2007 E2008 ## Min. : 2.809 Min. : 2.916 Min. : 3.022 Min. : 3.115 ## 1st Qu.: 41.646 1st Qu.: 42.497 1st Qu.: 43.203 1st Qu.: 44.262 ## Median : 54.765 Median : 55.506 Median : 56.552 Median : 57.522 ## Mean : 65.440 Mean : 66.180 Mean : 67.022 Mean : 67.950 ## 3rd Qu.: 75.003 3rd Qu.: 75.260 3rd Qu.: 75.790 3rd Qu.: 76.935 ## Max. :368.565 Max. :367.838 Max. :368.026 Max. :368.291 ## E2009 E2010 ## Min. : 3.238 Min. : 3.238 ## 1st Qu.: 45.062 1st Qu.: 45.062 ## Median : 58.077 Median : 58.077 ## Mean : 68.901 Mean : 68.901 ## 3rd Qu.: 78.166 3rd Qu.: 78.166 ## Max. :368.940 Max. :368.940 Modelling the raw standardized mortality rates (SMRs) Calculate the raw SMRs as. \\[ \\text{SMR} = \\dfrac{observed}{expected}\\] SMR_raw &lt;- observed[, -1] / expected # Rename columns names(SMR_raw) &lt;- c( &quot;SMR2001&quot;, &quot;SMR2002&quot;, &quot;SMR2003&quot;, &quot;SMR2004&quot;, &quot;SMR2005&quot;, &quot;SMR2006&quot;, &quot;SMR2007&quot;, &quot;SMR2008&quot;, &quot;SMR2009&quot;, &quot;SMR2010&quot; ) # Printing first six rows of raw SMRs head(SMR_raw) ## SMR2001 SMR2002 SMR2003 SMR2004 SMR2005 SMR2006 SMR2007 ## 00AA 0.7550261 0.0000000 1.1000648 0.3636943 0.3560423 0.3429382 1.6547601 ## 00AB 1.5638016 1.5768644 1.9498828 1.5135516 2.2413721 1.6253713 1.5558858 ## 00AC 0.9031554 0.8366462 0.8656520 0.7223915 0.7955030 0.7699460 0.5665330 ## 00AD 1.2084078 1.2384043 1.2289415 1.0349871 1.2063043 1.0253852 0.9848384 ## 00AE 0.8975442 1.1530694 0.8972291 0.7471429 0.7584911 0.5869024 0.6335828 ## 00AF 0.9147531 0.9750183 1.0130766 0.9217897 0.9381329 0.8516367 0.8655884 ## SMR2008 SMR2009 SMR2010 ## 00AA 0.3210586 0.0000000 0.3088328 ## 00AB 1.6637225 1.7641760 1.3624329 ## 00AC 0.6520466 0.5937205 0.6774503 ## 00AD 0.9191171 0.9523676 0.9523676 ## 00AE 0.5394928 0.6315370 0.4937471 ## 00AF 0.7598103 0.7608397 0.8035037 # Summarising raw SMRs summary(SMR_raw) ## SMR2001 SMR2002 SMR2003 SMR2004 ## Min. :0.3883 Min. :0.0000 Min. :0.3616 Min. :0.2778 ## 1st Qu.:0.7900 1st Qu.:0.8272 1st Qu.:0.8519 1st Qu.:0.7636 ## Median :0.9496 Median :1.0168 Median :1.0209 Median :0.9266 ## Mean :1.0349 Mean :1.0508 Mean :1.0895 Mean :0.9812 ## 3rd Qu.:1.2526 3rd Qu.:1.2364 3rd Qu.:1.3071 3rd Qu.:1.1858 ## Max. :1.9861 Max. :2.2181 Max. :2.2483 Max. :1.9811 ## SMR2005 SMR2006 SMR2007 SMR2008 ## Min. :0.3326 Min. :0.3429 Min. :0.3509 Min. :0.3211 ## 1st Qu.:0.7592 1st Qu.:0.7415 1st Qu.:0.7533 1st Qu.:0.7695 ## Median :0.9573 Median :0.9101 Median :0.9305 Median :0.9404 ## Mean :1.0126 Mean :0.9726 Mean :0.9743 Mean :1.0069 ## 3rd Qu.:1.2083 3rd Qu.:1.1586 3rd Qu.:1.1679 3rd Qu.:1.1979 ## Max. :2.2414 Max. :2.0805 Max. :1.8528 Max. :2.0567 ## SMR2009 SMR2010 ## Min. :0.0000 Min. :0.3088 ## 1st Qu.:0.7452 1st Qu.:0.7682 ## Median :0.8777 Median :0.9337 ## Mean :0.9328 Mean :0.9639 ## 3rd Qu.:1.0934 3rd Qu.:1.1335 ## Max. :1.8507 Max. :2.3856 Attach the values of the raw SMRs to the shapefiles. The function merge() allows us to combine a data frame with a shapefile to plot later. # Convert row names to ID column SMR_raw &lt;- tibble::rownames_to_column(SMR_raw, &quot;ID&quot;) # Combine raw SMRs and shapefiles SMRspatial_raw &lt;- merge(england, SMR_raw, by = &quot;ID&quot;) Use ggplot() and geom_sf() to create a map which colours the local authorities by the raw SMR estimate. # Creating breaks for legend in plot range &lt;- seq(min(SMR_raw$SMR2010) - 0.01, max(SMR_raw$SMR2010) + 0.01, length.out = 11) # Creating map of Raw SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = SMRspatial_raw, aes(fill = SMR2010)) + # Break points for colours scale_y_continuous(breaks = range) + # Clear background and plot borders theme( axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank(), rect = element_blank() ) Modelling a Poisson-Gamma with an MCMC implemented in R The following code shows how to implement the MCMC using only R for the COPD example. First, the constants are defined and the necessary vectors are initialized. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 # Number of MCMC iterations L &lt;- 80000 ## Initialize objects used in MCMC # Matrix for sampled values of parameter theta_i theta &lt;- matrix(ncol = length(y), nrow = L) # Matrix for fitted values fitted &lt;- theta # Vector for sampled values of hyper-parameter a a &lt;- c() # Vector for sampled values of hyper-parameter b b &lt;- c() ## Define constants # Sample size N &lt;- length(y) # Parameter of exponential prior for a lambda_a &lt;- 1 # Parameter of exponential prior for b lambda_b &lt;- 1 # standard deviation of the proposal distribution of log a u &lt;- 0.5 # Initialize theta theta[1, ] &lt;- y / E # Initial value sampled from the prior for a # REVIEW: In the example of the book theta ~ Ga(a,a) not Ga(a,b) a &lt;- rexp(1, lambda_a) # Initial value sampled from the prior for b b &lt;- rexp(1, lambda_b) fitted[1, ] &lt;- rpois(N, E * theta[1, ]) Once all the constants and initial values are set we can run the MCMC. The following code shows the MCMC implementation of a Poisson-Gamma model using only R. # Starting from l=2 as l=1 contains the initial values for(l in 2:L) { # Sampling from the posterior full conditional of each theta_i for (i in 1:N) theta[l, i] &lt;- rgamma(1, (y[i] + a[(l - 1)]), rate = (E[i] + b[(l - 1)])) # Sampling from the posterior full conditional of b # b[l] &lt;- b[l-1] # REVIEW: is this part of the comment? b[l] &lt;- rgamma(1, (N * a[(l - 1)] + 1), rate = (sum(theta[l, ]) + lambda_b)) # Metropolis-Hastings step to sample from the full conditional of &quot;a&quot; # the new value receives the current value in case the proposed # value is rejected a[l] &lt;- a[l - 1] # Proposal in the log-scale laprop &lt;- rnorm(1, log(a[l - 1]), u) aprop &lt;- exp(laprop) num &lt;- N * (aprop * (log(b[l])) - lgamma(aprop)) + (aprop - 1) * sum(log(theta[l, ])) - aprop * lambda_a + log(aprop) den &lt;- N * (a[l - 1] * (log(b[l])) - lgamma(a[l - 1])) + (a[(l - 1)] - 1) * sum(log(theta[l, ])) - a[(l - 1)] * lambda_a + log(a[(l - 1)]) ratio &lt;- exp(num - den) unif &lt;- runif(1) # Change the current value if the proposed value is accepted if (unif &lt; ratio) a[l] &lt;- aprop fitted[l,] &lt;- rpois(N, E * theta[l,]) } After running the MCMC, we should check if the chains have converged # Number of burn in samples burnin &lt;- 20000 thin &lt;- 30 # MCMC samples seqaux &lt;- seq(burnin, L, by = thin) # Trace-plots of the parameters xx &lt;- seq(0, 6, length = 2000) par(mfrow = c(2, 2)) # Plot for &quot;a&quot; plot(a[seqaux], type = &quot;l&quot;, bty = &quot;n&quot;) hist(a[seqaux], prob = 1, main = &quot;&quot;) lines(xx, dexp(xx, lambda_a), col = 2, lwd = 2) # COMBAK: This chains are not looking great # Plot for &quot;b&quot; plot(b[seqaux], type = &quot;l&quot;, bty = &quot;n&quot;) hist(b[seqaux], prob = 1, main = &quot;&quot;) lines(xx, dexp(xx, lambda_b), col = 2, lwd = 2) # Traceplots of theta&#39;s par(mfrow = c(3, 3)) for (i in 1:9) plot(theta[seqaux, i], type = &quot;l&quot;, bty = &quot;n&quot;) Given the convergence issues, we can also check the estimated sampled size and Rhat using the package coda. paste0(&quot;ESS a: &quot;, coda::effectiveSize(a[seqaux])) ## [1] &quot;ESS a: 43.8854656120712&quot; paste0(&quot;ESS b: &quot;, coda::effectiveSize(b[seqaux])) ## [1] &quot;ESS b: 47.6743541032327&quot; paste0(&quot;ESS theta[1]: &quot;, coda::effectiveSize(theta[seqaux, 1])) ## [1] &quot;ESS theta[1]: 2001&quot; paste0(&quot;ESS theta[10]: &quot;,coda::effectiveSize(theta[seqaux, 10])) ## [1] &quot;ESS theta[10]: 2001&quot; The variances for the parameters a and b is lower than the recommended minimum of 100. We will go back to this in Chapter 8. Now that we have guaranteed the convergence of the chains, we can look at the posterior summaries. # Posterior summaries of theta_i meantheta &lt;- apply(theta, 2, mean) q025theta &lt;- apply(theta, 2, function(x) quantile(x, 0.025)) q975theta &lt;- apply(theta, 2, function(x) quantile(x, 0.975)) # Plot the mean and 95% CIs for the thetas par(mfrow = c(1, 1)) plot( meantheta, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(q025theta), max(q975theta)) ) for (i in 1:N) segments(i, q025theta[i], i, q975theta[i]) abline(h = 1, lwd = 2, lty = 2) # Posterior summary of fitted values meanfit &lt;- apply(fitted, 2, mean) q025fit &lt;- apply(fitted, 2, function(x) quantile(x, 0.025)) q975fit &lt;- apply(fitted, 2, function(x) quantile(x, 0.975)) # Plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, meanfit, ylim = c(min(q025fit), max(q975fit)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], q025fit[i], y[i], q975fit[i]) abline(a = 0, b = 1) Example 6.3: Fitting a Poisson regression model in Nimble Load nimble package library(&quot;nimble&quot;) The following code is used to fit the Poisson log-linear model seen in Chapter 2 Section … using Nimble First, define the model in Nimble. Example5_3Code &lt;- nimbleCode({ for (i in 1:N) { Y[i] ~ dpois(mu[i]) log(mu[i]) &lt;- log(E[i]) + beta0 + beta1 * X1[i] + betad * X2[i] } # Priors beta0 ~ dnorm (0 , sd = 100) beta1 ~ dnorm (0 , sd = 100) betad ~ dnorm (0 , sd = 100) # Functions of interest: base &lt;- exp(beta0) RR &lt;- exp(beta1) }) Read the data and define the constants, data and initials lists for the Nimble model. # REVIEW: Is this another version of the COPD data? Is there a data dictionary for this dataset? data &lt;- read.csv(&quot;data/DataExample53.csv&quot;, sep = &quot;,&quot;) ex.const &lt;- list( N = 393, E = data$exp_lungc65pls, X1 = as.vector(scale(data$k3)), X2 = as.vector(scale(data$k2)) ) ex.data &lt;- list(Y = data$lungc65pls) inits &lt;- function() list(beta0 = rnorm(1), beta1 = rnorm(1), betad = rnorm(1)) # Define parameters to monitor and run the model params &lt;- c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;betad&quot;, &quot;base&quot;, &quot;RR&quot;) samples &lt;- nimbleMCMC( code = Example5_3Code, data = ex.data, constants = ex.const, inits = inits, monitors = params, niter = 22000, nburnin = 2000, thin = 10, WAIC = TRUE, nchains = 2, samplesAsCodaMCMC = TRUE ) Check the WAIC. samples$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 3049.634 ## Field &quot;lppd&quot;: ## [1] -1514.39 ## Field &quot;pWAIC&quot;: ## [1] 10.4274 Show the trace plots and posterior summaries for each of the parameters. mvSamples &lt;- samples$samples #trace plots of beta1 plot(mvSamples[, c(&quot;beta1&quot;)]) #trace plots of base plot(mvSamples[, c(&quot;base&quot;)]) #trace plots of RR plot(mvSamples[, c(&quot;RR&quot;)]) #posterior summary of base summary(mvSamples[, c(&quot;base&quot;)]) ## ## Iterations = 1:2000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 2000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## 1.1284738 0.0124003 0.0001961 0.0001904 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## 1.105 1.120 1.128 1.137 1.152 #posterior summary of RR summary(mvSamples[, c(&quot;RR&quot;)]) ## ## Iterations = 1:2000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 2000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## 1.0148175 0.0179830 0.0002843 0.0004284 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## 0.9795 1.0025 1.0150 1.0272 1.0494 "],["Strategies.html", "Chapter 7 Strategies implementing uncertainty models", " Chapter 7 Strategies implementing uncertainty models This chapter considers both some of the wider issues related to modelling and the generalisability of results and more technical material on the effect of covariates and model selection. From this chapter, the reader will have gained an understanding of the following topics: Why having contrasts in the variables of interest is important in assessing the effects they have on the response variable. The biases that may arise in the presence of covariates and how covariates can affect variable selection and model choice. Hierarchical models and how that can be used to acknowledge dependence between observations. There are issues with using p–values as measures of evidence against a null hypothesis. Basing scientific conclusions on it can lead to non-reproducible results. The use of predictions from exposure models including acknowledging the additional uncertainty involved when using predictions as inputs to a health model. Methods for performing model selection, including the pros and cons of automatic selection procedures. Model selection within the Bayesian setting and how the models themselves can be incorporated into the estimation process using Bayesian Model Averaging. "],["trusted.html", "Chapter 8 But can the data be trusted 8.1 Solutions to Selected Exercises", " Chapter 8 But can the data be trusted This chapter considers some of the issues that will arise when dealing with ‘real data’. Data will commonly have missing values and may be measured with error. This error might be random or may be due to systematic patterns in how it was collected. From this chapter, the reader will have gained an understanding of the following topics: Classification of missing values into missing at random or not at random. Methods for imputing missing values. Various measurement models including classical and Berkson. The attenuation of regression coefficients under measurement error. Preferential sampling, where the process that determines the locations of monitoring sites and the process being modelled are in some ways dependent. How preferential sampling can bias the measurements that arise from environmental monitoring networks 8.1 Solutions to Selected Exercises 8.1.1 PLACEHOLDER: Repeat the Black Smoke analysis conducted in Watson et al. 2019. in the “naive” model. If INLA is not already installed, it needs to be done manually (https://www.r-inla.org/download-install): install.packages( &quot;INLA&quot;, repos = c(getOption(&quot;repos&quot;), INLA = &quot;https://inla.r-inla-download.org/R/stable&quot;), dep = TRUE ) After INLA is installed load all the necessary packages. library(INLA) library(mvtnorm) library(boot) library(geoR) library(reshape2) library(sp) library(ggplot2) Assuming the data is held in the file BlackSmokePrefData.csv in a /data directory: BlackSmokePrefData &lt;- read.csv(&quot;data/BlackSmokePrefData.csv&quot;) head(BlackSmokePrefData) ## standardize location coordinates sd_x &lt;- sd(BlackSmokePrefData[, c(2)]) sd_y &lt;- sd(BlackSmokePrefData[, c(3)]) BlackSmokePrefData[, 2] &lt;- BlackSmokePrefData[, 2] / sd_x BlackSmokePrefData[, 3] &lt;- BlackSmokePrefData[, 3] / sd_y We need to reshape the data to have one observation per row, as required by INLA. yearmeans = colMeans(BlackSmokePrefData[,-c(1, 2, 3)], na.rm = T) ## save means for each year BlackSmokePrefData &lt;- melt( BlackSmokePrefData, id.vars = c(1, 2, 3), variable.name = &#39;year&#39;, value.name = &#39;bsmoke&#39; ) BlackSmokePrefData$year = as.numeric(as.character(factor(BlackSmokePrefData$year, labels = 66:96))) ## standardize by mean of mean of each year to make it unitless BlackSmokePrefData$bsmoke = BlackSmokePrefData$bsmoke / mean(yearmeans) ## log-transform to eliminate right skew BlackSmokePrefData$bsmoke = log(BlackSmokePrefData$bsmoke) Producing the 2-d mesh of the UK: no_sites = as.numeric(length(unique(BlackSmokePrefData$site))) # number of sites no_T = as.numeric(length(unique(BlackSmokePrefData$year))) # number of years ncol = 100 # grid for projection nrow = 100 L = nrow * ncol # number of grid sites # Form the regular mesh # # Create a rough convex boundary for the UK # # Form the grid independently from the sites to avoid preferential grid selection # UK_domain = cbind(c(2, 7.7, 7.7, 6, 4, 1), c(0.5, 0.5, 6, 13.5, 13.5, 12)) hull = inla.nonconvex.hull(cbind(BlackSmokePrefData$east, BlackSmokePrefData$north)) cutoff_dist = 16000 / sd_x # 16km as min edge max.edge = 100000 / sd_x # 100km max edge as in Shaddick and Zidek # NOTE: JOHNNY, I HAD TO COMMENT THE CUTOFF VARIABLE CAUSE OTHERWISE IT WOULDN&#39;T WORK mesh = inla.mesh.2d( loc = cbind(BlackSmokePrefData$east, BlackSmokePrefData$north), boundary = hull, offset = c(0.1, 0.2), max.edge = c(cutoff_dist, 0.5), #cutoff = c(cutoff_dist, 1), min.angle = 26 ) plot(mesh) points(BlackSmokePrefData$east, BlackSmokePrefData$north, col = &quot;red&quot;) Now we define and fit our INLA model. spde_obj = inla.spde2.pcmatern( mesh = mesh, alpha = 2, prior.range = c(0.04, 0.05), prior.sigma = c(1, 0.01), constr = T ) A_proj = inla.spde.make.A( mesh = mesh, loc = as.matrix(cbind( BlackSmokePrefData$east, BlackSmokePrefData$north )), group = BlackSmokePrefData$year - 65, # group membership needs to be 1:no_T n.group = no_T ) s_index = inla.spde.make.index(name = &quot;spatial.field&quot;, n.spde = spde_obj$n.spde, n.group = no_T) time = (1:no_T) / no_T time2 = time ^ 2 # create the stack object for estimating observation process y # cov_y = data.frame( year = rep(time, each = no_sites), year_2 = rep(time2, each = no_sites), spatial_ind = rep(1:no_sites, times = no_T), spatial_ind2 = no_sites + rep(1:no_sites, times = no_T) ) # site-specific random intercepts # Needs copies to include covariate twice s_index_copy = s_index names(s_index_copy) = c(&#39;spatial.field.copy&#39;, &quot;spatial.field.group.copy&quot;, &quot;spatial.field.repl.copy&quot;) s_index_copy2 = s_index names(s_index_copy2) = c(&#39;spatial.field.copy2&#39;, &quot;spatial.field.group.copy2&quot;, &quot;spatial.field.repl.copy2&quot;) stack_y_est = inla.stack( data = list( y = BlackSmokePrefData$bsmoke, #single model alldata = cbind(BlackSmokePrefData$bsmoke, NA, NA), Ntrials = rep(0, times = length(BlackSmokePrefData$bsmoke)) ), #joint model A = list(A_proj, A_proj, A_proj, 1), effects = list( c(s_index, list(Intercept = 1)), c(s_index_copy, list(Intercept_copy = 1)), c(s_index_copy2, list(Intercept_copy2 = 1)), cov_y ), tag = &#39;y_est&#39; ) formula_naive = y ~ -1 + Intercept + f(spatial.field, model = spde_obj) + f(spatial.field.copy, I(spatial.field.group.copy / no_T), model = spde_obj) + f(spatial.field.copy2, I((spatial.field.group.copy2 / no_T) ^ 2), model = spde_obj) + I(spatial.field.group / no_T) + I((spatial.field.group / no_T) ^ 2) + f(year, model = &#39;ar1&#39;) + f(spatial_ind, model = &quot;iid2d&quot;, n = no_sites * 2, constr = TRUE) + #random site-specific intercepts f(spatial_ind2, year, copy = &quot;spatial_ind&quot;) theta.ini = c( 1.597900, -1.277423, -0.443820, -1.441220, 0.036510, -1.441336, 0.016919, 4.462918, 1.437147, 4, 4, 4 ) out.naive = inla( formula_naive, family = &#39;gaussian&#39;, data = inla.stack.data(stack_y_est), control.predictor = list(A = inla.stack.A(stack_y_est), compute = F), control.compute = list(dic = F, config = T, cpo = F), control.inla = list(strategy = &quot;gaussian&quot;, int.strategy = &#39;eb&#39;), control.mode = list(theta = theta.ini, restart = T), verbose = T, num.threads = 2 ) We can now take posteriors from the model. m_samples = 50 samp &lt;- inla.posterior.sample(m_samples, out.naive) for (i in 1:m_samples) { samp[[i]]$latent = samp[[i]]$latent[-c(grep(&#39;Predictor&#39;, rownames(samp[[i]]$latent), fixed = T)), ] } Finally, summarize and plot the outputs: stepsize = 5000 / sd_x nxy = round(c(diff(range( BlackSmokePrefData$east )), diff(range( BlackSmokePrefData$north ))) / stepsize) ## how many points? proj_grid = inla.mesh.projector( mesh, xlim = range(BlackSmokePrefData$east), ylim = range(BlackSmokePrefData$north), dims = nxy ) A.grid = inla.spde.make.A(mesh, loc = cbind(BlackSmokePrefData$east, BlackSmokePrefData$north)) ## define placeholders tmp2 = matrix(0, nrow = no_T, ncol = mesh$n) year = (1:no_T) / no_T year2 = year ^ 2 Post_Array2 = array(0, dim = c(m_samples, no_T, mesh$n)) Post_Sites_Array2 = array(0, dim = c(m_samples, no_T, dim(BlackSmokePrefData)[1])) residuals_array = array(0, dim = c(m_samples, no_T, dim(BlackSmokePrefData)[1])) RI_array = array(0, dim = c(m_samples, no_T, dim(BlackSmokePrefData)[1])) # random intercepts RS_array = array(0, dim = c(m_samples, no_T, dim(BlackSmokePrefData)[1])) # random slopes for (i in 1:m_samples) { # Creating predictions for Y process for (j in 1:no_T) # loop over the years { Post_Array2[i, j, ] &lt;- samp[[i]]$latent[&#39;Intercept:1&#39;] + # Intercept samp[[i]]$latent[which(startsWith(prefix = &#39;year:&#39;, x = names(samp[[i]]$latent)))][j] * year[j] + # linear fixed effect #samp[[i]]$latent[&#39;year_2&#39;] * year2[j] + # quadratic fixed effect as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial.field:&#39;, x = names(samp[[i]]$latent)))]) + # Spatial Intercept as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial.field.copy:&#39;, x = names(samp[[i]]$latent)))]) * year[j] + # Spatial linear slope as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial.field.copy2:&#39;, x = names(samp[[i]]$latent)))]) * year2[j] # Spatial quadratic slope # Project onto the site locations and add random site-specific effects # Post_Sites_Array2[i, j, ] = as.numeric(A.grid %*% Post_Array2[i, j, ]) + as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial_ind:&#39;, x = names(samp[[i]]$latent)))[1:no_sites]]) + # random Intercept as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial_ind2:&#39;, x = names(samp[[i]]$latent)))[no_sites + (1:no_sites)]]) * year[j] # random slope # Extract the random intercepts # RI_array[i, j, ] = as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial_ind:&#39;, x = names(samp[[i]]$latent)))[1:no_sites]]) # Extract the random slopes # RS_array[i, j, ] = as.numeric(samp[[i]]$latent[which(startsWith(prefix = &#39;spatial_ind2:&#39;, x = names(samp[[i]]$latent)))[no_sites + (1:no_sites)]]) } } ## summarizing Post_mean2 &lt;- t(apply(Post_Array2, c(2, 3), function(x) { mean(x, na.rm = TRUE) })) Post_sd2 &lt;- t(apply(Post_Array2, c(2, 3), function(x) { sd(x, na.rm = TRUE) })) Post_LCL2 &lt;- apply((apply(Post_Array2, c(1, 2), function(x) { mean(x, na.rm = TRUE) })), 2, quantile, probs = c(0.025)) Post_UCL2 &lt;- apply((apply(Post_Array2, c(1, 2), function(x) { mean(x, na.rm = TRUE) })), 2, quantile, probs = c(0.975)) RI_array &lt;- t(apply(RI_array, c(2, 3), function(x) { mean(x, na.rm = TRUE) })) RS_array &lt;- t(apply(RS_array, c(2, 3), function(x) { mean(x, na.rm = TRUE) })) ## placeholders for uniform grid posterior blacksmoke values (not necessarily in dataset) post_Matrix_grid_mean2 = array(NA, dim = c(nxy[1], nxy[2], no_T)) post_Matrix_grid_sd2 = array(NA, dim = c(nxy[1], nxy[2], no_T)) for (i in 1:no_T) { post_Matrix_grid_mean2[, , i] = inla.mesh.project(proj_grid, Post_mean2[, i]) post_Matrix_grid_sd2[, , i] = inla.mesh.project(proj_grid, Post_sd2[, i]) } ## placeholders for observed (R1 = active, R0 = inactive) site blacksmoke values R1_results2 = matrix(NA, nrow = no_T, ncol = 4) # prediction means, sd, LCL, UCL colnames(R1_results2) = c(&#39;predciction mean&#39;, &#39;prediction sd&#39;, &#39;LCL&#39;, &#39;UCL&#39;) R0_results2 = matrix(NA, nrow = no_T, ncol = 4) # prediction means, sd, LCL, UCL colnames(R0_results2) = c(&#39;predciction mean&#39;, &#39;prediction sd&#39;, &#39;LCL&#39;, &#39;UCL&#39;) Grid_results2 = matrix(NA, nrow = no_T, ncol = 4) # prediction means, sd, LCL, UCL colnames(Grid_results2) = c(&#39;predciction mean&#39;, &#39;prediction sd&#39;, &#39;LCL&#39;, &#39;UCL&#39;) BlackSmokePrefData_original &lt;- read.csv(&quot;data/BlackSmokePrefData.csv&quot;) ## need original columns here for (j in 1:no_T) { R1_results2[j, 1] = mean(Post_Sites_Array2[, j, which(!is.na(BlackSmokePrefData_original[, 3 + j]))], na.rm = T) R1_results2[j, 2] = sd(apply(Post_Sites_Array2[, j, which(!is.na(BlackSmokePrefData_original[, 3 + j]))], c(1), mean, na.rm = T)) R1_results2[j, 3] = quantile(apply(Post_Sites_Array2[, j, which(!is.na(BlackSmokePrefData_original[, 3 + j]))], 1, mean, na.rm = T), probs = 0.025) R1_results2[j, 4] = quantile(apply(Post_Sites_Array2[, j, which(!is.na(BlackSmokePrefData_original[, 3 + j]))], 1, mean, na.rm = T), probs = 0.975) R0_results2[j, 1] = mean(Post_Sites_Array2[, j, which(is.na(BlackSmokePrefData_original[, 3 + j]))], na.rm = T) R0_results2[j, 2] = sd(apply(Post_Sites_Array2[, j, which(is.na(BlackSmokePrefData_original[, 3 + j]))], c(1), mean, na.rm = T)) R0_results2[j, 3] = quantile(apply(Post_Sites_Array2[, j, which(is.na(BlackSmokePrefData_original[, 3 + j]))], 1, mean, na.rm = T), probs = 0.025) R0_results2[j, 4] = quantile(apply(Post_Sites_Array2[, j, which(is.na(BlackSmokePrefData_original[, 3 + j]))], 1, mean, na.rm = T), probs = 0.975) } for (i in 1:no_T) { Grid_results2[i, 1] = mean(post_Matrix_grid_mean2[, , i], na.rm = T) Grid_results2[i, 2] = mean(post_Matrix_grid_sd2[, , i], na.rm = T) } Grid_results2[, 3] = Post_LCL2 Grid_results2[, 4] = Post_UCL2 ## Revert to the original scale (exponentiating and scaling up) Grid_df_2 = data.frame( y = exp(c( Grid_results2[, 1], R1_results2[, 1], R0_results2[, 1] )) * mean(yearmeans), x = rep(66:96, times = 3), ymin = exp(c(Post_LCL2, R1_results2[, 3], R0_results2[, 3])) * mean(yearmeans), ymax = exp(c(Post_UCL2, R1_results2[, 4], R0_results2[, 4])) * mean(yearmeans), group = c( rep(&#39;Whole UK&#39;, times = 31), rep(&#39;R1&#39;, times = 31), rep(&#39;R0&#39;, times = 31) ) ) ## plotting Grid_plot_2 = ggplot(aes( x = x, y = y, ymin = ymin, ymax = ymax, alpha = 0.05 ), data = Grid_df_2) + geom_ribbon(aes( colour = group, alpha = 0.05, fill = group )) + xlab(&#39;year&#39;) + ylab(&#39;posterior mean bs on transformed scale&#39;) + ggtitle( &#39;Naive posterior means of BS at the selected, unselected sites and across the UK (R1, R0 and Whole UK resp.). &#39; ) Grid_plot_2 "],["Disease.html", "Chapter 9 Disease-spatial patterns Example 9.1: Empirical Bayes and Bayes smoothing of COPD mortality for 2010 Example 9.3: Fitting a conditional spatial model in nimble and stan Example 9.4: Fitting a conditional spatial model using CARBayes Example 9.5: Fitting a conditional model using INLA", " Chapter 9 Disease-spatial patterns This chapter introduces disease mapping and contains the theory for spatial lattice processes and models for performing smoothing of risks over space. From this chapter, the reader will have gained an understanding of the following topics: Disease mapping, where we have seen how to improve estimates of risk by borrowing strength from adjacent regions which can reduce the instability inherent in risk estimates (SMRs) based on small expected numbers. Seen how smoothing can be performed using either the empirical Bayes or fully Bayesian approaches. Been introduced to computational methods for handling areal data. Learned about Besag’s seminal contributions to the field of spatial statistics including the very important concept of a Markov random field. Explored approaches to modelling a real data including the conditional auto regressive models. Seen how Bayesian spatial models for lattice data use nimble, stan, R and R–INLA. Example 9.1: Empirical Bayes and Bayes smoothing of COPD mortality for 2010 Nimble Following Example 6.2 we look back at the hospital admission rates for COPD, in England for 2010. We can implement the same model we used on Example 6.2 using nimble. # Load nimble library(nimble) library(sf) # to read shapefile # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) The following is the code for the Poisson-Gamma model implemented in nimble. Example9_1Nimble &lt;- nimbleCode({ for (i in 1:N) { Y[i] ~ dpois(mu[i]) # REVIEW: There is an intercept in the book, # but then we wouldn&#39;t be able to compare it to example 5.2 mu[i] &lt;- E[i] * theta[i] # REVIEW: Same as before, the example in the book has theta[i] ~ Ga(a,a) theta[i] ~ dgamma(a, b) Y.fit[i] ~ dpois(mu[i]) } # Priors a ~ dexp(lambda_a) b ~ dexp(lambda_b) }) Define the constants, data and initials lists for the nimble model. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 N &lt;- length(y) # parameter of exponential prior for a lambda_a &lt;- 1 # parameter of exponential prior for b lambda_b &lt;- 1 # constants list constants &lt;- list( N = N, E = E, lambda_a = lambda_a, lambda_b = lambda_b ) # data list ex.data &lt;- list(Y = y) # initial values list inits &lt;- list( theta = rgamma(N, 1, 1), a = rexp(1, lambda_a), b = rexp(1, lambda_b), Y.fit = rpois(N, E) ) # parameters to monitor params &lt;- c(&quot;theta&quot;, &quot;a&quot;, &quot;b&quot;, &quot;Y.fit&quot;) # Run model in nimble mcmc.out &lt;- nimbleMCMC( code = Example9_1Nimble, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 50000, nburnin = 20000, thin = 30, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) Show the WAIC, effective sample size, and trace plots for some of the parameters. mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 2416.115 ## Field &quot;lppd&quot;: ## [1] -1060.158 ## Field &quot;pWAIC&quot;: ## [1] 147.8992 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 222.8207 mvSamples &lt;- mcmc.out$samples # trace plot of a plot(mvSamples[, c(&quot;a&quot;)], bty = &quot;n&quot;) # trace plot of b plot(mvSamples[, c(&quot;b&quot;)], bty = &quot;n&quot;) # trace plots of theta for (i in 1:3) plot(mvSamples[, c(paste(&quot;theta[&quot;, i, &quot;]&quot;, sep = &quot;&quot;))], bty = &quot;n&quot;) Now that we have checked the convergence of the chains we can plot the posterior mean and 95% CIs for each of the parameters. # Print posterior summary for parameters a and b summary(mvSamples[, c(&quot;a&quot;, &quot;b&quot;)]) ## ## Iterations = 1:1000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 1000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## a 11.76 1.004 0.02246 0.06659 ## b 12.09 1.047 0.02340 0.07009 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## a 9.895 11.07 11.72 12.39 13.90 ## b 10.105 11.40 12.07 12.76 14.29 # posterior summaries of theta_i post_summary &lt;- mcmc.out$summary$all.chains |&gt; as.data.frame() |&gt; tibble::rownames_to_column(&quot;variable&quot;) # plot the mean and 95% CIs for the thetas post_theta &lt;- post_summary[grepl(&quot;theta\\\\[&quot;, post_summary$variable), ] par(mfrow = c(1, 1)) plot( post_theta$Mean, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(post_theta$`95%CI_low`), max(post_theta$`95%CI_upp`)) ) for (i in 1:N) segments(i, post_theta$`95%CI_low`[i], i, post_theta$`95%CI_upp`[i]) abline(h = 1, lwd = 2, lty = 2) # posterior summary of fitted values post_fitted &lt;- post_summary[grepl(&quot;Y.fit\\\\[&quot;, post_summary$variable), ] # plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, post_fitted$Mean, ylim = c(min(post_fitted$`95%CI_low`), max(post_fitted$`95%CI_upp`)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], post_fitted$`95%CI_low`[i], y[i], post_fitted$`95%CI_upp`[i]) abline(a = 0, b = 1) Stan Load necessary libraries and data. library(rstan) library(sf) # to read shapefile library(loo) # To calculate WAIC options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) Write the stan model. This model is in a separate file called Example8_1.stan that will be called later. data { int&lt;lower=0&gt; N; real&lt;lower=0&gt; E[N]; // need to indicate that variable is strictly positive int&lt;lower=0&gt; Y[N]; real&lt;lower=0&gt;lambda_a; real&lt;lower=0&gt;lambda_b; } parameters { real&lt;lower=0&gt; theta[N]; real&lt;lower=0&gt; a; real&lt;lower=0&gt; b; } transformed parameters{ real &lt;lower=0&gt; mu[N]; for(i in 1:N){ mu[i]=E[i]*theta[i]; } } model { // likelihood function and prior for theta for(i in 1:N){ Y[i] ~ poisson(mu[i]); theta[i]~gamma(a,b); } a~exponential(lambda_a); b~exponential(lambda_b); } generated quantities { vector [N] log_lik; int&lt;lower=0&gt; yfit [N]; //computing the log_likelihood for each value of the mean mu and the fitted values for(i in 1:N){ log_lik[i]=poisson_lpmf(Y[i] |mu[i]); yfit[i]=poisson_rng(mu[i]); } } Define the data for the model, similar to nimble. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 N &lt;- length(y) # data list ex.data &lt;- list( N = length(y), Y = y, E = E, lambda_a = 1, lambda_b = 1 ) # Run the model in Stan Ex9_1Stan &lt;- stan( file = &quot;functions/Example9_1.stan&quot;, data = ex.data, chains = 3, iter = 10000, warmup = 3000, thin = 14, # QUESTION: should we explain this? control = list(adapt_delta = 0.8, max_treedepth = 15), init = &quot;random&quot;, pars = c(&quot;a&quot;, &quot;b&quot;, &quot;theta&quot;, &quot;log_lik&quot;, &quot;yfit&quot;), include = TRUE ) Compute the WAIC, show the trace plots and posterior summaries of the parameters. loglik0 &lt;- extract_log_lik(Ex9_1Stan) waic0 &lt;- waic(loglik0) waic0 ## ## Computed from 1500 by 324 log-likelihood matrix ## ## Estimate SE ## elpd_waic -1209.1 7.6 ## p_waic 148.9 3.3 ## waic 2418.3 15.1 ## ## 186 (57.4%) p_waic estimates greater than 0.4. We recommend trying loo instead. # traceplots of parameters a and b traceplot(Ex9_1Stan, pars = c(&quot;a&quot;, &quot;b&quot;)) # traceplots of parameter theta traceplot(Ex9_1Stan, pars = c(&quot;theta[1]&quot;, &quot;theta[2]&quot;, &quot;theta[3]&quot;)) summary_theta &lt;- summary(Ex9_1Stan, pars = c(&quot;theta&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() par(mfrow = c(1, 1)) plot( summary_theta$mean, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(summary_theta$`5%`), max(summary_theta$`95%`)) ) for (i in 1:N) segments(i, summary_theta$`5%`[i], i, summary_theta$`95%`[i]) abline(h = 1, lwd = 2, lty = 2) # Posterior summary of fitted values summary_fit &lt;- summary(Ex9_1Stan, pars = c(&quot;yfit&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() # Plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, summary_fit$mean, ylim = c(min(summary_fit$`5%`), max(summary_fit$`95%`)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], summary_fit$`5%`[i], y[i], summary_fit$`95%`[i]) abline(a = 0, b = 1) Example 9.3: Fitting a conditional spatial model in nimble and stan Nimble In this example we revisit the COPD data from example 6.3. library(ggplot2) # to plot map library(spdep) # read the shapefile (read_sf) and build neighbors list (poly2nb) library(nimble) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # remove axis line ) } # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;) covariates &lt;- read.csv(file = &quot;data/copdavgscore.csv&quot;) # Merge everything into one data frame copd_df &lt;- cbind(observed, expected) |&gt; merge( covariates, by.x = &quot;code&quot;, by.y = &quot;LA.CODE&quot;, all.x = TRUE, all.y = FALSE ) Analyze the relationship between COPD data and the average deprivation score which is a measure of the socioeconomic status of the patients. copd_df$SMR2010 = copd_df$Y2010 / copd_df$E2010 ggplot(copd_df) + geom_point(aes(x = Average.Score, y = SMR2010)) + theme_clear() + ylab(&quot;SMR 2010&quot;) + xlab(&quot;Average deprivation score&quot;) Define a function to obtain the number of neighbors. adjlist = function(W, N) { adj = 0 for (i in 1:N) { for (j in 1:N) { if (W[i, j] == 1) { adj = append(adj, j) } } } adj = adj[-1] return(adj) } Define the adjacency matrix and indexes for stan using the nb2mat and adjlist # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) # Define the spatial structure to use in stan N &lt;- length(unique(england$ID)) neigh &lt;- adjlist(W.mat, N) numneigh &lt;- apply(W.mat,2,sum) Example9_3Nimble &lt;- nimbleCode({ # Likelihood for (i in 1:N) { y[i] ~ dpois(lambda[i]) log(lambda[i]) &lt;- log(E[i]) + b[i] + beta0 + beta1*x[i] } # Priors beta0 ~ dnorm(0, sd = 1) beta1 ~ dnorm(0, sd = 1) b[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau, zero_mean = 1) tau &lt;- 1 / (sigma_b ^ 2) sigma_b ~ T(dnorm(0, sd = 1), 0,) # Fitted values and likelihood for WAIC for (i in 1:N) { fitted[i] ~ dpois(lambda[i]) } }) Define the constants, data and initial values lists and run the model. # constants list constants &lt;- list( N = N, E = copd_df$E2010, L = length(neigh), adj = neigh, weights = rep(1, length(neigh)), num = as.vector(numneigh), p = 3 ) # data list ex.data &lt;- list(y = copd_df$Y2010, x = as.vector(scale(copd_df$Average.Score))) # vector of covariates inits &lt;- list( beta0 = rnorm(1), beta1 = rnorm(1), fitted = rpois(N, 2), sigma_b = 1, b = rnorm(N) ) params &lt;- c(&quot;beta0&quot;,&quot;beta1&quot;, &quot;fitted&quot;, &quot;b&quot;, &quot;sigma_b&quot;) # Run model in nimble mcmc.out &lt;- nimbleMCMC( code = Example9_3Nimble, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 40000, nburnin = 20000, thin = 80, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) Show the WAIC, effective sample size, and trace plots for some of the parameters. mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 2391.275 ## Field &quot;lppd&quot;: ## [1] -1080.128 ## Field &quot;pWAIC&quot;: ## [1] 115.5094 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 328.9784 plot(mcmc.out$samples[, c(&quot;beta0&quot;)], bty = &quot;n&quot;, main = &quot;beta0&quot;) plot(mcmc.out$samples[, c(&quot;beta1&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;b[2]&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;sigma_b&quot;)], bty = &quot;n&quot;) # Extract samples variables &lt;- c(&quot;beta0&quot;, &quot;beta1&quot;,&quot;sigma_b&quot;) summary_CAR_nimble &lt;- mcmc.out$summary$all.chains summary_CAR_nimble[variables,] ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## beta0 -0.06907407 -0.06947976 0.007582475 -0.08372619 -0.05363491 ## beta1 0.18190912 0.18097399 0.012335381 0.15855232 0.20676643 ## sigma_b 0.25784264 0.25739130 0.019839060 0.22196062 0.29767482 Map the mean of the posterior estimate for the latent effect. samples_CAR_b &lt;- summary_CAR_nimble[grepl(&quot;b\\\\[&quot;, rownames(summary_CAR_nimble)), ] |&gt; as.data.frame() observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) samples_CAR_b$ID &lt;- observed$ID CAR_nimble_merge &lt;- merge(england, samples_CAR_b, by = &quot;ID&quot;) ggplot() + # Choose spatial object and column for plotting geom_sf(data = CAR_nimble_merge, aes(fill = Mean)) + # Change legend&#39;s label labs(fill = &#39;Latent effects nimble&#39;) + # Clear background and plot borders theme_void() Stan Here, we implement the CAR model using stan. We will need two functions to structure the matrix of neighbors that will be needed in stan. adjlist = function(W, N) { adj = 0 for (i in 1:N) { for (j in 1:N) { if (W[i, j] == 1) { adj = append(adj, j) } } } adj = adj[-1] return(adj) } mungeCARdata4stan = function(adjBUGS, numBUGS) { N = length(numBUGS) nn = numBUGS N_edges = length(adjBUGS) / 2 node1 = vector(mode = &quot;numeric&quot;, length = N_edges) node2 = vector(mode = &quot;numeric&quot;, length = N_edges) iAdj = 0 iEdge = 0 for (i in 1:N) { for (j in 1:nn[i]) { iAdj = iAdj + 1 if (i &lt; adjBUGS[iAdj]) { iEdge = iEdge + 1 node1[iEdge] = i node2[iEdge] = adjBUGS[iAdj] } } } return (list( &quot;N&quot; = N, &quot;N_edges&quot; = N_edges, &quot;node1&quot; = node1, &quot;node2&quot; = node2 )) } Define the adjacency matrix and indexes for stan using the nb2mat and adjlist # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) # Define the spatial structure to use in stan N &lt;- length(unique(england$ID)) neigh &lt;- adjlist(W.mat, N) numneigh &lt;- apply(W.mat, 2, sum) nbs &lt;- mungeCARdata4stan(neigh, numneigh) N &lt;- nbs$N node1 &lt;- nbs$node1 node2 &lt;- nbs$node2 N_edges &lt;- nbs$N_edges This model is in a separate file called Example8_3.stan that will be called later. data { int&lt;lower=1&gt; N; int&lt;lower=1&gt; N_edges; int&lt;lower=1&gt; p; matrix[N,p] X; int&lt;lower=1, upper=N&gt; node1[N_edges]; // node1[i] adjacent to node2[i] int&lt;lower=1, upper=N&gt; node2[N_edges]; // and node1[i] &lt; node2[i] int&lt;lower=0&gt; y[N]; // count outcomes vector&lt;lower=0&gt;[N] E; // exposure } transformed data { vector[N] log_E = log(E); } parameters { real beta0; // intercept vector[p] beta; vector[N] s; // spatial effects real&lt;lower=0&gt; sigma_s; // marginal standard deviation of spatial effects } transformed parameters { vector[N] b; // latent effect b = sigma_s*s; } model { y ~ poisson_log(log_E + beta0 + X*beta + b); // This is the prior for s! (up to proportionality) target += -0.5 * dot_self(s[node1] - s[node2]); sum(s) ~ normal(0, 0.001 * N); beta0 ~ normal(0.0, 10.0); for(j in 1:p){ beta[j] ~ normal(0.0, 10.0); } sigma_s ~ normal(0.0,1.0); } generated quantities { vector[N] mu=exp(log_E + beta0 + X*beta + b); vector[N] lik; vector[N] log_lik; for(i in 1:N){ lik[i] = exp(poisson_lpmf(y[i] | mu[i] )); log_lik[i] = poisson_lpmf(y[i] | mu[i] ); } } N_edges &lt;- N_edges node1 &lt;- node1 node2 &lt;- node2 N &lt;- N y &lt;- copd_df$Y2010 E &lt;- copd_df$E2010 X &lt;- as.numeric(scale(copd_df$Average.Score)) ex.data &lt;- list( N = N, y = y, E = E, p = 1, X = as.matrix(X), N_edges = N_edges, node1 = node1, node2 = node2 ) Example9_3Stan &lt;- stan( file = &quot;functions/Example9_3.stan&quot;, data = ex.data, warmup = 10000, iter = 20000, chains = 2, thin = 10, pars = c(&quot;beta0&quot;, &quot;beta&quot;,&quot;sigma_s&quot;, &quot;b&quot;, &quot;log_lik&quot;), include = TRUE ) Show traceplots. #computing WAIC using the package loo loglikcar &lt;- extract_log_lik(Example9_3Stan) waiccar &lt;- waic(loglikcar) ## Warning: ## 89 (27.5%) p_waic estimates greater than 0.4. We recommend trying loo instead. waiccar ## ## Computed from 2000 by 324 log-likelihood matrix ## ## Estimate SE ## elpd_waic -1195.4 14.2 ## p_waic 115.6 6.9 ## waic 2390.8 28.3 ## ## 89 (27.5%) p_waic estimates greater than 0.4. We recommend trying loo instead. traceplot(Example9_3Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;,&quot;sigma_s&quot;)) Show the posterior summary for the parameters if interest. Keep in mind that in the stan model the we are sampling the standard deviation of the random effect unlike CARBayes where the variance is obtained. # Extract samples summary_CAR_stan &lt;- summary( Example9_3Stan, pars = c(&quot;beta0&quot;, &quot;beta&quot;,&quot;sigma_s&quot;), probs = c(0.025, 0.975) ) summary_CAR_stan$summary ## mean se_mean sd 2.5% 97.5% n_eff ## beta0 -0.06917609 0.0001700692 0.007517408 -0.08348142 -0.05381922 1953.823 ## beta[1] 0.18177056 0.0003016124 0.012414403 0.15695866 0.20587785 1694.156 ## sigma_s 0.25839436 0.0005109142 0.020668533 0.21863991 0.30059932 1636.528 ## Rhat ## beta0 0.9992591 ## beta[1] 0.9992871 ## sigma_s 1.0000812 Map the mean of the posterior estimate for the latent effect. summary_CAR_stan_b &lt;- summary( Example9_3Stan, pars = c(&quot;b&quot;), probs = c(0.025, 0.975) ) observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) summary_CAR_stan_b$ID &lt;- observed$ID CAR_stan_merge &lt;- merge(england, summary_CAR_stan_b, by = &quot;ID&quot;) ggplot() + # Choose spatial object and column for plotting geom_sf(data = CAR_stan_merge, aes(fill = summary.mean)) + # Change legend&#39;s label labs(fill = &#39;Latent effects stan&#39;) + # Clear background and plot borders theme_void() Example 9.4: Fitting a conditional spatial model using CARBayes Load the necessary libraries and the COPD data. As in example 5.2 englandlocalauthority.shp and it’s related files contain the location, shape, and attributes of English local authorities. library(CARBayes) library(ggplot2) library(sf) library(spdep) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_blank()# remove axis line ) } # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;) covariates &lt;- read.csv(file = &quot;data/copdavgscore.csv&quot;) # Merge everything into one data frame copd_df &lt;- cbind(observed, expected) |&gt; merge( covariates, by.x = &quot;code&quot;, by.y = &quot;LA.CODE&quot;, all.x = TRUE, all.y = FALSE ) copd_df$Average.Score &lt;- as.numeric(scale(copd_df$Average.Score)) To calculate the smoother SMRs, we first need to create a neighborhood structure. The functions poly2nb() and nb2mat() from the spdep package can be used to create this # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) Here, we use first neighbors to define the structure, so any local authority sharing a border are considered neighbors. The function S.CARleroux() allows us to use the neighborhood structure and performs a Bayesian analysis to create a smoothed set of observed values. # Running smoothing model Ex9_4 &lt;- S.CARleroux( # Model Formula formula = Y2010 ~ offset(log(E2010)) + Average.Score, # data frame with data data = copd_df, # Choosing Poisson Regression family = &quot;poisson&quot;, # Neighborhood matrix W = W.mat, # Number of burn in samples burnin = 20000, # Number of MCMC samples n.sample = 100000, thin = 10, rho = 1 ) We can extract the new smoother values from the model output and divide them by the expected values in order to compare both methods. # Creating a dataset with smoothed SMRs in 2010 SMR2010 &lt;- Ex9_4$fitted.values / copd_df$E2010 SMR_smooth &lt;- as.data.frame(SMR2010, row.names = rownames(observed)) # Printing first six rows of smoothed SMRs head(SMR_smooth) ## SMR2010 ## 00AA 0.6748541 ## 00AB 1.3180090 ## 00AC 0.6660958 ## 00AD 0.9449000 ## 00AE 0.7466276 ## 00AF 0.8299810 # Summarizing smoothed SMRs summary(SMR_smooth) ## SMR2010 ## Min. :0.6011 ## 1st Qu.:0.7908 ## Median :0.9015 ## Mean :0.9638 ## 3rd Qu.:1.0831 ## Max. :1.7971 # Summary of the parameters under the CAR model. Ex9_4$summary.results[] ## Mean 2.5% 97.5% n.sample % accept n.effective Geweke.diag ## (Intercept) -0.0689 -0.0843 -0.0537 8000 38.8 7621.3 -0.2 ## Average.Score 0.1818 0.1576 0.2057 8000 38.8 2594.7 0.2 ## tau2 0.0650 0.0466 0.0885 8000 100.0 3325.8 -0.6 ## rho 1.0000 1.0000 1.0000 NA NA NA NA Use ggplot() and geom_sf() to plot the map of the latent spatial effect. observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) phi_car &lt;- Ex9_4$samples$phi latent_car_df &lt;- data.frame( phi_mean = apply(phi_car, 2, mean), phi_sd = apply(phi_car, 2, sd) ) # Combine latent spatial effect with england dataset latent_car_df$ID &lt;- observed$ID latent_car_england &lt;- merge(england, latent_car_df, by = &quot;ID&quot;) # Creating map of smoothed SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = latent_car_england, aes(fill = phi_mean)) + labs(fill = &#39;Latent effects CARbayes&#39;) + # Clear background and plot borders theme_void() Example 9.5: Fitting a conditional model using INLA # run the INLA model Ex9_5 &lt;- inla( Y2010 ~ Average.Score + f(ID , model = &quot;besag&quot;, graph = &quot;UK.adj&quot;), family = &quot;poisson&quot;, E = E2010, data = copd_df, control.predictor = list(compute = TRUE) ) Summarize the results # Summarizing smoothed SMRs summary(Ex9_5) ## ## Call: ## c(&quot;inla.core(formula = formula, family = family, contrasts = contrasts, ## &quot;, &quot; data = data, quantiles = quantiles, E = E, offset = offset, &quot;, &quot; ## scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, ## &quot;, &quot; lp.scale = lp.scale, link.covariates = link.covariates, verbose = ## verbose, &quot;, &quot; lincomb = lincomb, selection = selection, control.compute ## = control.compute, &quot;, &quot; control.predictor = control.predictor, ## control.family = control.family, &quot;, &quot; control.inla = control.inla, ## control.fixed = control.fixed, &quot;, &quot; control.mode = control.mode, ## control.expert = control.expert, &quot;, &quot; control.hazard = control.hazard, ## control.lincomb = control.lincomb, &quot;, &quot; control.update = ## control.update, control.lp.scale = control.lp.scale, &quot;, &quot; ## control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, ## &quot;, &quot; inla.call = inla.call, inla.arg = inla.arg, num.threads = ## num.threads, &quot;, &quot; blas.num.threads = blas.num.threads, keep = keep, ## working.directory = working.directory, &quot;, &quot; silent = silent, inla.mode ## = inla.mode, safe = FALSE, debug = debug, &quot;, &quot; .parent.frame = ## .parent.frame)&quot;) ## Time used: ## Pre = 0.491, Running = 0.217, Post = 0.0425, Total = 0.751 ## Fixed effects: ## mean sd 0.025quant 0.5quant 0.975quant mode kld ## (Intercept) -0.069 0.008 -0.084 -0.069 -0.054 NA 0 ## Average.Score 0.182 0.012 0.158 0.182 0.206 NA 0 ## ## Random effects: ## Name Model ## ID Besags ICAR model ## ## Model hyperparameters: ## mean sd 0.025quant 0.5quant 0.975quant mode ## Precision for ID 15.94 2.62 11.54 15.69 21.64 NA ## ## Marginal log-Likelihood: -1493.26 ## is computed ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also &#39;control.compute=list(return.marginals.predictor=TRUE)&#39;) observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) phi_car &lt;- Ex9_5$summary.random$ID latent_car_df &lt;- data.frame( phi_mean = phi_car$mean, phi_sd = phi_car$sd ) # Combine latent spatial effect with england dataset latent_car_df$ID &lt;- observed$ID latent_car_england &lt;- merge(england, latent_car_df, by = &quot;ID&quot;) # Creating map of smoothed SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = latent_car_england, aes(fill = phi_mean)) + labs(fill = &#39;Latent effects INLA&#39;) + # Clear background and plot borders theme_void() "],["hazards.html", "Chapter 10 Environmental hazards-spatial models Example 10.1 Spatial patterns of benzene concentrations in Montreal, QC, Canada Example 10.2: Examining the log concentrations of benzene in Montreal Example 10.3: Mapping the locations of ozone monitoring sites in New York State Example 10.5: Variogram Example 10.6 Basic spatial modelling and prediction of benzene in Montreal Example 10.9 Spatial modelling of Benzene in Montreal Example 10.12: Fitting an SPDE model using R–INLA: benzene concentration in Montreal Example 10.13: Directional variograms", " Chapter 10 Environmental hazards-spatial models This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics: Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps. Exploring the underlying structure of spatial data and methods for characterizing dependence over space. Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations. Stationarity and isotropy. Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging). Non-stationarity fields. Example 10.1 Spatial patterns of benzene concentrations in Montreal, QC, Canada Map the locations of the monitoring stations in Montreal. library(cowplot) library(geoR) library(ggmap) library(spdep) # Load data on benzene concentration in Montreal benzene &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # TODO: Add description of the data, this is the April campaign # create a new variable in &quot;sp&quot; format and define coordinates benzene_geo &lt;- benzene coordinates(benzene_geo) &lt;- ~ lon + lat proj4string(benzene_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) # specify the bounding box latLongBox = bbox(benzene_geo) location = c(latLongBox[1, 1] - 0.05, latLongBox[2, 1] - 0.05, latLongBox[1, 2] + 0.1, latLongBox[2, 2] + 0.05) # create map with location dots marked on it in MontrelBenzeneMap &lt;- get_stamenmap(bbox = location, zoom = 10) ggmap(MontrelBenzeneMap) + geom_point(data = benzene, aes(x = lon, y = lat, size = Benzene), col = &quot;#011f4b&quot;, alpha = 0.45) + theme_void() Using the geoR package we can also plot the following: the locations of the sampling sites the concentrations of ozone in relation to the x and y coordinates and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density. # convert data to utm coordinates benzene_utm &lt;- spTransform(benzene_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_utm) colnames(benzene_utm_df) &lt;- c(&quot;Benzene&quot;, &quot;X&quot;, &quot;Y&quot;) # Save as geodata to generate the geodata plot benzene_geodata &lt;- as.geodata(benzene_utm_df, coords.col = 2:3, data.col = 1) plot(benzene_geodata) Example 10.2: Examining the log concentrations of benzene in Montreal # Histogram for the log of the benzene concentration par(mfrow=c(1,2)) log_histogram &lt;- hist(log(benzene$Benzene), main = &quot;&quot;, xlab = &quot;log(Benzene)&quot;) qqnorm(log(benzene$Benzene), bty = &quot;n&quot;) qqline(log(benzene$Benzene)) Example 10.3: Mapping the locations of ozone monitoring sites in New York State # Load the metadata giving the site coordinates ny_data &lt;- read.csv(&quot;data/NY_metadata.txt&quot;, sep=&quot;&quot;) # Now copy ny_data into ny_data_sp and convert data to &quot;sp&quot; format ny_data_sp &lt;- ny_data coordinates(ny_data_sp) &lt;- ~Longitude+Latitude # assign a reference system to ny_data_sp proj4string(ny_data_sp) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) # We next specify a bounding box - a 2 x 2 matrix of corners of the geographic # area. Then specify the range of locations within the box. # Note: location must bounding box format be in left -bottom -right -top latLongBox &lt;- bbox(ny_data_sp) location &lt;- c(latLongBox [1, 1] - 0.2 , latLongBox [2, 1] - 0.2, latLongBox [1, 2] + 0.2 , latLongBox [2, 2] + 0.2) # Now create the map with location dots NYmap &lt;- get_stamenmap( bbox = location, zoom = 8 ) ggmap(NYmap) + geom_point( data = ny_data, aes(x = Longitude , y = Latitude), size = 4, color = &quot;darkred&quot; ) + theme_void() Example 10.5: Variogram library(gstat) benzene_utm_geo &lt;- benzene_utm_df # get the coordinates in kms and turn into a Spatial object benzene_utm_geo[,c(&quot;X&quot;, &quot;Y&quot;)] &lt;- benzene_utm_geo[,c(&quot;X&quot;, &quot;Y&quot;)]/1000 coordinates(benzene_utm_geo) &lt;- ~ X + Y # Estimate variogram intercept only benzene_inter_vgm &lt;- variogram(log(Benzene)~ 1, data = benzene_utm_geo, cutoff = 20, # cutoff distance width = 20/10 # bins width ) benzene_inter_vgm_fit &lt;- fit.variogram(benzene_inter_vgm, model = vgm(0.1, &quot;Exp&quot;, 15, 0.02)) benzene_inter_vgm_fit ## model psill range ## 1 Nug 0.01616521 0.00000 ## 2 Exp 0.17301314 23.97153 # Estimate variogram using coordinates benzene_vgm &lt;- variogram(log(Benzene)~ X + Y, data = benzene_utm_geo, cutoff = 20, # cutoff distance width = 20/10 # bins width ) benzene_vgm_fit &lt;- fit.variogram(benzene_vgm, model = vgm(0.1, &quot;Exp&quot;, 3, 0.02)) benzene_vgm_fit ## model psill range ## 1 Nug 0.01638881 0.000000 ## 2 Exp 0.05598753 7.365469 plot_inter_variog &lt;- plot(benzene_inter_vgm, benzene_inter_vgm_fit, bty = &quot;n&quot;) plot_coord_variog &lt;- plot(benzene_vgm, benzene_vgm_fit, bty = &quot;n&quot;) plot_grid(plot_inter_variog, plot_coord_variog, labels = &quot;auto&quot;) Example 10.6 Basic spatial modelling and prediction of benzene in Montreal # Generate grid MtlPred &lt;- expand.grid(seq (580, 615 , 0.5), seq (5020, 5060 , 0.5) ) # change names grid names(MtlPred)[ names(MtlPred)==&quot;Var1&quot;] &lt;- &quot;X&quot; names(MtlPred)[ names(MtlPred)==&quot;Var2&quot;] &lt;- &quot;Y&quot; # make the grid a Spatial object coordinates (MtlPred) = ~ X + Y gridded(MtlPred) = TRUE # define the model based on the variogram fit from the previous example mod &lt;- vgm (0.053 , &quot;Exp&quot;, 5.54, 0.0122) # use ordinary kriging to predict values in the grid x &lt;- krige(log(Benzene) ~ X + Y, benzene_utm_geo , MtlPred , model = mod ) ## [using universal kriging] # Plot the ordinary kriging predictions and their variance monitor_loc &lt;- list(&#39;sp.points&#39;, benzene_utm_geo, pch=19, cex=.8, col=&#39;cornsilk4&#39;) krig_pred &lt;- spplot ( x[&quot;var1.pred&quot;], main = &quot;Ordinary kriging predictions &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(-0.3, 0.8, 0.02) ) krig_var &lt;- spplot ( x[&quot;var1.var&quot;], main = &quot;Ordinary kriging variance &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(0, 0.2, 0.01) ) plot_grid(krig_pred, krig_var, labels = &quot;auto&quot;) Example 10.9 Spatial modelling of Benzene in Montreal Nimble library(coda) library(geoR) library(magrittr) library(nimble) library(spdep) library(tidyverse) library(tidybayes) # Load data on benzene concentration in Montreal benzene &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_geo &lt;- benzene coordinates(benzene_geo) &lt;- ~ lon + lat proj4string(benzene_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_utm &lt;- spTransform(benzene_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_utm) # Change coordinates to kilometers and observations to the log scale Mtl_benzene_sample &lt;- data.frame( y = log(benzene_utm_df$Benzene), easting = benzene_utm_df$lon / 1000, northing = benzene_utm_df$lat / 1000 ) # Compute the distance matrix obsCoords &lt;- unname(as.matrix(Mtl_benzene_sample[,c(&quot;easting&quot;, &quot;northing&quot;)])) obsDist &lt;- fields::rdist(obsCoords) Example10_9Code &lt;- nimbleCode ({ # Covariance matrix spatial effect Sigma[1:n, 1:n] &lt;- sigma_sq * exp(-distMatrix[1:n, 1:n] / phi) + tau_sq * identityMatrix(d = n) for (site in 1:n) { mean.site[site] &lt;- beta0 + beta1 * easting[site] + beta2 * northing[site] } y[1:n] ~ dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n]) # Set up the priors for the spatial model sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) sigma_sq &lt;- sigma^2 tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) tau_sq &lt;- tau^2 phi_inv ~ dgamma(shape = 5, rate = 5) phi &lt;- 1 / phi_inv # prior for the coefficients beta0 ~ dnorm (0, 10) beta1 ~ dnorm (0, 10) beta2 ~ dnorm (0, 10) }) Define the constants, data and initials lists for the nimble model. # Define the constants, data, parameters and initial values set.seed(1) easting_scaled &lt;- as.vector(scale(Mtl_benzene_sample$easting)) northing_scaled &lt;- as.vector(scale(Mtl_benzene_sample$northing)) constants &lt;- list(n = nrow(Mtl_benzene_sample)) ex.data &lt;- list(y = Mtl_benzene_sample$y, easting = easting_scaled, northing = northing_scaled, distMatrix = obsDist) params &lt;- c( &quot;beta0&quot;, &quot;beta1&quot;,&quot;beta2&quot;, &quot;phi&quot;, &quot;tau&quot;, &quot;sigma&quot;, &quot;tau_sq&quot;, &quot;sigma_sq&quot;) inits &lt;- list( sigma = 0.1, phi_inv = 6/max(obsDist), tau = 0.1) # Run model in nimble start_time &lt;- Sys.time() mcmc.out &lt;- nimbleMCMC( code = Example10_9Code, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 40000, nburnin = 20000, thin = 14, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) end_time &lt;- Sys.time() run_time &lt;- end_time - start_time run_time mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] -32.37684 ## Field &quot;lppd&quot;: ## [1] 19.03084 ## Field &quot;pWAIC&quot;: ## [1] 2.842421 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 985.2176 plot(mcmc.out$samples[, c(&quot;beta0&quot;)], bty = &quot;n&quot;, main = &quot;beta0&quot;) plot(mcmc.out$samples[, c(&quot;beta1&quot;)], bty = &quot;n&quot;, main = &quot;beta1&quot;) plot(mcmc.out$samples[, c(&quot;beta2&quot;)], bty = &quot;n&quot;, main = &quot;beta2&quot;) plot(mcmc.out$samples[, c(&quot;sigma&quot;)], bty = &quot;n&quot;, main = &quot;sigma&quot;) plot(mcmc.out$samples[, c(&quot;tau&quot;)], bty = &quot;n&quot;, main = &quot;tau&quot;) plot(mcmc.out$samples[, c(&quot;phi&quot;)], bty = &quot;n&quot;, main = &quot;phi&quot;) mcmc.out$summary$all.chains[c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;beta2&quot;, &quot;sigma_sq&quot;, &quot;tau_sq&quot;, &quot;phi&quot;), ] ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## beta0 0.143589662 0.15187505 0.081381727 -4.284934e-02 0.27866526 ## beta1 0.051028164 0.04806334 0.060619017 -6.338295e-02 0.17328888 ## beta2 0.077775628 0.08250220 0.068519017 -7.013084e-02 0.20323633 ## sigma_sq 0.056087887 0.05202343 0.022624353 2.770244e-02 0.11140808 ## tau_sq 0.009128758 0.00841011 0.006709036 5.744089e-05 0.02380432 ## phi 3.697646345 3.09115863 2.228726265 1.463844e+00 9.40053808 # Obtain coordinates for predictions # note that we are using the same coordinates as the one generated for # the kriging example Mtl_centroids_df &lt;- as.data.frame(MtlPred) predCoords &lt;- unname(as.matrix(Mtl_centroids_df)) Following the posterior predictive distribution we have to define a model for the predictions. # Extract samples from nimble model tidy_post_samples &lt;- mcmc.out$samples %&gt;% tidy_draws() # Extract posterior samples for each of the parameters of interest post_beta0 &lt;- tidy_post_samples$beta0 post_beta1 &lt;- tidy_post_samples$beta1 post_beta2 &lt;- tidy_post_samples$beta2 post_sigmasq &lt;- tidy_post_samples$sigma_sq post_phi &lt;- tidy_post_samples$phi post_tausq &lt;- tidy_post_samples$tau_sq # Scale coordinates for predictive locations predCoords_sc &lt;- predCoords predCoords_sc[,1] &lt;- (predCoords_sc[,1] - mean(Mtl_benzene_sample$easting)) / sd(Mtl_benzene_sample$easting) predCoords_sc[,2] &lt;- (predCoords_sc[,2] - mean(Mtl_benzene_sample$northing)) / sd(Mtl_benzene_sample$northing) n0 &lt;- nrow(predCoords_sc) L &lt;- length(post_tausq) obsMu &lt;- cbind(1, easting_scaled, northing_scaled) %*% t(cbind(post_beta0, post_beta1, post_beta2)) predMu &lt;- cbind(1, as.matrix(predCoords_sc)) %*% t(cbind(post_beta0, post_beta1, post_beta2)) pred2obsDist &lt;- fields::rdist(predCoords, obsCoords) Rcpp::sourceCpp(&quot;functions/prediction_marginal_gp12.cpp&quot;) args(prediction_marginal_gp12) ## function (y, obsMu, predMu, obsDistMat, pred2ObsDistMat, sigmasq, ## phi, tausq, iterprint) ## NULL system.time( pred_samples &lt;- prediction_marginal_gp12( y = Mtl_benzene_sample$y, obsMu = obsMu, predMu = predMu, obsDistMat = obsDist, pred2ObsDistMat = pred2obsDist, sigmasq = post_sigmasq, phi = post_phi, tausq = post_tausq, iterprint = 1000 ) ) ## Prediction upto the 0th MCMC sample is completed ## Prediction upto the 1000th MCMC sample is completed ## Prediction upto the 2000th MCMC sample is completed ## user system elapsed ## 140.11 0.14 174.86 str(pred_samples) ## num [1:5751, 1:2856] -0.116 -0.805 -0.7 -0.327 -0.402 ... predict_res_dt &lt;- data.frame( xcoord = predCoords[, 1], ycoord = predCoords[, 2], post.mean = apply(pred_samples, 1, mean), post.var = apply(pred_samples, 1, var), q2.5 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.025)), q50 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.5)), q97.5 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.975)) ) x$nimble.pred &lt;- predict_res_dt$post.mean x$nimble.var &lt;- predict_res_dt$post.var nimble_pred &lt;- spplot ( x[&quot;nimble.pred&quot;], main = &quot;Nimble spatial predictions &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(-0.3, 0.8, 0.02) ) nimble_var &lt;- spplot ( x[&quot;nimble.var&quot;], main = &quot;Nimble predictions variance &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(0, 0.2, 0.01) ) plot_grid(nimble_pred, nimble_var, labels = &quot;auto&quot;) Stan benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_geo &lt;- benzene_data coordinates(benzene_data_geo) &lt;- ~ lon + lat proj4string(benzene_data_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_data_utm &lt;- spTransform(benzene_data_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_data_utm) # change the observed values to the log scale and the coordinates to km&#39;s Mtl_benzene_sample &lt;- data.frame( y = log(benzene_utm_df$Benzene), easting = benzene_utm_df$lon / 1000, northing = benzene_utm_df$lat / 1000 ) # Compute the distance matrix obsCoords &lt;- unname(as.matrix(Mtl_benzene_sample[,c(&quot;easting&quot;, &quot;northing&quot;)])) obsDist &lt;- fields::rdist(obsCoords) data { int&lt;lower=1&gt; N; int&lt;lower=0&gt; p; vector[N] y; matrix[N,N] dist_matrix; matrix[N,p] X; } parameters { real&lt;lower=0&gt; phi; real&lt;lower=0&gt; tau; real&lt;lower=0&gt; sigma; vector[p] beta; real beta0; } transformed parameters{ real&lt;lower=0&gt; sigma_sq = square(sigma); real&lt;lower=0&gt; tau_sq = square(tau); } model { vector[N] mu; matrix[N, N] L; matrix[N, N] Sigma; for(i in 1:(N-1)){ for(j in (i+1):N){ Sigma[i,j] = sigma_sq*exp(-dist_matrix[i,j]/phi); Sigma[j,i] = Sigma[i,j]; } } // diagonal elements for(i in 1:N) { Sigma[i,i] = sigma_sq + tau_sq; mu[i] = beta0 + X[i,]*beta; } L = cholesky_decompose(Sigma); beta0 ~ normal(0,10); beta ~ normal(0,10); phi ~ inv_gamma(5, 5); tau ~ cauchy(0,1); sigma ~ cauchy(0,1); y ~ multi_normal_cholesky(mu, L); } set.seed(1) easting_scaled &lt;- as.vector(scale(Mtl_benzene_sample$easting)) northing_scaled &lt;- as.vector(scale(Mtl_benzene_sample$northing)) N &lt;- nrow(benzene_utm_df) # Change coordinates to kilometers X &lt;- data.frame(easting = easting_scaled, northing = northing_scaled) ex.data &lt;- list( N = N, p = 2, y = log(benzene_utm_df$Benzene), dist_matrix = obsDist, X = as.matrix(X) ) Example10_9Stan &lt;- stan( file = &quot;functions/Example10_9.stan&quot;, data = ex.data, warmup = 10000, iter = 20000, chains = 2, thin = 10, pars = c(&quot;beta0&quot;, &quot;beta&quot;, &quot;sigma_sq&quot;, &quot;tau_sq&quot;, &quot;phi&quot;), include = TRUE ) rstan::traceplot(Example10_9Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;,&quot;sigma_sq&quot;, &quot;tau_sq&quot;, &quot;phi&quot;)) summary_exp_stan &lt;- summary( Example10_9Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;, &quot;phi&quot;, &quot;sigma_sq&quot;, &quot;tau_sq&quot;), probs = c(0.025, 0.975) ) summary_exp_stan$summary ## mean se_mean sd 2.5% 97.5% n_eff ## beta0 0.153151957 0.0017454630 0.082542739 -0.0280454381 0.30104542 2236.333 ## beta[1] 0.048260898 0.0014210620 0.060763462 -0.0628368700 0.17050377 1828.349 ## beta[2] 0.079958055 0.0015912122 0.068248714 -0.0763104700 0.19962566 1839.640 ## phi 3.577291239 0.0500854445 2.111837928 1.5099031977 9.06193864 1777.862 ## sigma_sq 0.055305541 0.0004872241 0.021205779 0.0277406700 0.10511771 1894.310 ## tau_sq 0.009140308 0.0001587922 0.006624496 0.0001113095 0.02330228 1740.394 ## Rhat ## beta0 1.0000400 ## beta[1] 1.0010770 ## beta[2] 0.9997490 ## phi 0.9997624 ## sigma_sq 1.0022418 ## tau_sq 0.9998860 # Obtain coordinates for predictions # note that we are using the same coordinates as the one generated for # the kriging example Mtl_centroids_df &lt;- as.data.frame(MtlPred) predCoords &lt;- unname(as.matrix(Mtl_centroids_df)) # Extract samples from nimble model stan_post_samples &lt;- rstan::extract(Example10_9Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;, &quot;phi&quot;, &quot;sigma_sq&quot;, &quot;tau_sq&quot;)) # Extract posterior samples for each of the parameters of interest post_beta0 &lt;- stan_post_samples$beta0 post_beta &lt;- stan_post_samples$beta # post_beta2 &lt;- stan_post_samples$beta2 post_sigmasq &lt;- stan_post_samples$sigma_sq post_phi &lt;- stan_post_samples$phi post_tausq &lt;- stan_post_samples$tau_sq # Scale coordinates for predictive locations predCoords_sc &lt;- predCoords predCoords_sc[,1] &lt;- (predCoords_sc[,1] - mean(Mtl_benzene_sample$easting)) / sd(Mtl_benzene_sample$easting) predCoords_sc[,2] &lt;- (predCoords_sc[,2] - mean(Mtl_benzene_sample$northing)) / sd(Mtl_benzene_sample$northing) n0 &lt;- nrow(predCoords_sc) L &lt;- length(post_tausq) obsMu &lt;- cbind(1, easting_scaled, northing_scaled) %*% t(cbind(post_beta0, post_beta)) predMu &lt;- cbind(1, as.matrix(predCoords_sc)) %*% t(cbind(post_beta0, post_beta)) pred2obsDist &lt;- fields::rdist(predCoords, obsCoords) Rcpp::sourceCpp(&quot;functions/prediction_marginal_gp12.cpp&quot;) args(prediction_marginal_gp12) ## function (y, obsMu, predMu, obsDistMat, pred2ObsDistMat, sigmasq, ## phi, tausq, iterprint) ## NULL system.time( pred_samples &lt;- prediction_marginal_gp12( y = Mtl_benzene_sample$y, obsMu = obsMu, predMu = predMu, obsDistMat = obsDist, pred2ObsDistMat = pred2obsDist, sigmasq = post_sigmasq, phi = post_phi, tausq = post_tausq, iterprint = 1000 ) ) ## Prediction upto the 0th MCMC sample is completed ## Prediction upto the 1000th MCMC sample is completed ## user system elapsed ## 99.34 0.03 123.03 predict_res_dt &lt;- data.frame( xcoord = predCoords[, 1], ycoord = predCoords[, 2], post.mean = apply(pred_samples, 1, mean), post.var = apply(pred_samples, 1, var), q2.5 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.025)), q50 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.5)), q97.5 = apply(pred_samples, 1, function(x) quantile(x, prob = 0.975)) ) x$stan.pred &lt;- predict_res_dt$post.mean x$stan.var &lt;- predict_res_dt$post.var stan_pred &lt;- spplot ( x[&quot;stan.pred&quot;], main = &quot;Stan spatial predictions &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(-0.3, 0.8, 0.02) ) stan_var &lt;- spplot ( x[&quot;stan.var&quot;], main = &quot;Stan predictions variance &quot;, col.regions = viridis::plasma(60), sp.layout = list(monitor_loc), at = seq(0, 0.2, 0.01) ) plot_grid(stan_pred, stan_var, labels = &quot;auto&quot;) ## Example 10.11: INLA, creating a mesh {-} library(geoR) library(INLA) library(spdep) benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_loc &lt;- benzene_data coordinates(benzene_data_loc) &lt;- ~ lon + lat proj4string(benzene_data_loc) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_data_utm &lt;- spTransform(benzene_data_loc, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame locations_df &lt;- as.data.frame(benzene_data_utm@coords) benzene_utm_df &lt;- data.frame( ID = 1:nrow(benzene_data), X = benzene_data_utm@coords[,1]/1000, Y = benzene_data_utm@coords[,2]/1000, logbenzene = log(benzene_data_utm$Benzene)) # change the observed values to the log scale and the coordinates to km&#39;s mesh = inla.mesh.create(locations_df, cutoff = 0.01, refine =(list(min.angle =20))) plot(mesh , col=&quot;gray&quot;, main=&quot;&quot;) # ukmap &lt;- readShapeLines(&quot;uk_BNG.shp&quot;) plot(mesh , col=&quot;gray&quot;, main=&quot;&quot;) # lines(ukmap) # points(locations , col=&quot;red&quot;, pch=20,bg=&quot;red&quot;) Example 10.12: Fitting an SPDE model using R–INLA: benzene concentration in Montreal # Field std . dev . for theta =0 sigma0 = 1 # find the range of the location data size = min(c(diff(range(mesh$loc[, 1])), diff (range(mesh$loc[, 2])))) # A fifth of the approximate domain width . range0 = size/5 kappa0 = sqrt(8)/range0 tau0 = 1/(sqrt (4*pi)*kappa0*sigma0) spde = inla.spde2.matern ( mesh, B.tau = cbind(log (tau0), -1, +1), B.kappa = cbind(log (kappa0), 0, -1), theta.prior.mean = c(0 , 0), constr = TRUE ) formula = logbenzene ~ 1 + X + Y + f(ID , model = spde) model = inla( formula, family = &quot;gaussian&quot;, data = benzene_utm_df , control.predictor = list(compute = TRUE), control.compute = list(dic = TRUE , config = TRUE) ) model$summary.fixed ## mean sd 0.025quant 0.5quant 0.975quant ## (Intercept) 4.830402981 120.70808847 -186.92784218 -12.919627484 318.31464884 ## X 0.013798753 0.02139307 -0.02634336 0.012253906 0.06493462 ## Y -0.002602772 0.02423337 -0.06477481 0.000935161 0.03597768 ## mode kld ## (Intercept) NA 1.151149e-04 ## X NA 1.817937e-04 ## Y NA 7.297007e-05 Example 10.13: Directional variograms ### Compute and plot the directional variogram CA.geo &lt;- as.geodata( benzene_utm_df , coords.col = 2:3 , data.col=1) CA.vario4 &lt;- variog4(CA.geo ) plot(CA.vario4) –&gt; "],["Time.html", "Chapter 11 Time-why it also matters Example 11.1 Ground level ozone concentrations Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average Example 11.13 Forecasting ozone levels Example 11.14 Forecasting volcanic ash Example 11.16 implementation of a dynamic linear model", " Chapter 11 Time-why it also matters The chapter contains the theory required for handling time series data. From this chapter, the reader will have gained an understanding of the following topics: That a temporal process consists of both low and high frequency components, the former playing a key role in determining long-term trends while the latter may be associated with shorter-term changes. Techniques for the exploratory analysis of the data generated by the temporal process, including the ACF (correlogram) and PACF (periodogram). Models for irregular (high frequency) components after the regular components (trend) have been removed. Methods for forecasting, including exponential smoothing and ARIMA modelling. The state space modelling approach, which sits naturally within a Bayesian setting and which provides a general framework for most of the classical time series models and many more besides. Implementing time series processes within a Bayesian hierarchical framework. Example 11.1 Ground level ozone concentrations Load the daily and hourly data for one site. library(ggplot2) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # change the format of the date column site_daily$date &lt;- as.Date(site_daily$date, &quot;%m/%d/%Y&quot;) # load hourly data from that same site site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Plot the daily and hourly time series. # Plot daily data ggplot(data = site_daily) + geom_line(aes(x = date, y = max.ozone, group = 1)) + # draw a line at the first data geom_vline(xintercept = as.Date(&quot;2013-01-01&quot;), color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm) geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + theme_clear() # Plot hourly data ggplot(data = site_hourly,) + geom_line(aes(x = time, y = ozone, group = 1)) + geom_vline(xintercept = 1, color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm). geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Hour in 2013&#39;s ozone season&quot;) + ylab(&quot;Hourly Ozone Concentration (ppm)&quot;) + theme_clear() Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average For this example we will use the TTR package (Technical Trading Rules). This allow us to manipulate objects like time series for forecasting. library(TTR) # Load daily data site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # add an identifier column for each day in the sample site_daily$day &lt;- 1:nrow(site_daily) # add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } # Add loess smooth # Single day ozone.loess &lt;- loess(max.ozone ~ day, span = 0.75, data = site_daily[,c(&quot;max.ozone&quot;, &quot;day&quot;)]) ozone.predict &lt;- predict(ozone.loess, data.frame(day = 1:nrow(site_daily))) ozone.predict_df &lt;- data.frame(day = 1:nrow(site_daily), ozone.prediction = ozone.predict) ggplot(data = site_daily) + geom_line(aes(x = day, y = max.ozone, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Single day&quot;) + theme_clear() # Three days ozone_SMA3 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 3), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA3) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Three days&quot;) + theme_clear() # Six days ozone_SMA6 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 6), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA6) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Six days&quot;) + theme_clear() # Twelve days ozone_SMA12 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 12), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA12) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Twelve days&quot;) + theme_clear() Example 11.13 Forecasting ozone levels library(TTR) library(forecast) # Load hourly data for site 060379033 site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # one night hour per day missing for instrument calibration - imputed for simplicity imputeNA &lt;- mean(site_hourly$ozone, na.rm = TRUE) site_hourly$ozone[is.na(site_hourly$ozone)] &lt;- imputeNA # Select the first seven days in july # days_pattern contains the dates for the first seven days days_pattern &lt;- paste0(&quot;^2013070&quot;, 1:7, collapse=&quot;|&quot;) # select all the rows that follow that pattern using grepl july_seven_days &lt;- site_hourly[grepl(days_pattern, site_hourly$datetime),] july_seven_days$hours &lt;- 1:nrow(july_seven_days) # Holt-Winters model fitting # Turn this into a time series object to use Holt-Winters forecast level_ts &lt;- ts(july_seven_days$ozone, frequency = 24, start = c(1)) ozone_forecast &lt;- HoltWinters(level_ts) # Plot using the default function plot( ozone_forecast, xlab = &quot;Hours - First Week -July 2013&quot;, ylab = &quot;O3 (ppm)&quot;, col.predicted = 1, col = &quot;black&quot;, bty = &quot;n&quot;, lty = 2 ) # Holt- Winters 24 ahead forast on Day 8 # no need to specify Holt-Winters forecast as the object is already HoltWinters class ozoneforecast_day8 &lt;- forecast(ozone_forecast, h=24) # Plot using default function plot(ozoneforecast_day8, bty = &quot;n&quot;) Example 11.14 Forecasting volcanic ash The data in this example consists of atmospheric levels of volcanic ash from 1500AD to 2000AD. library(ggplot2) library(forecast) library(TTR) # Load volcano dust data ## REVIEW: Data source: Hyn�d�man, R.J. Time Series Data Library, http://data.is/TSDLdemo # Data cover the period from 1500AD to 2000AD volcano_dust &lt;- scan(&quot;https://robjhyndman.com/tsdldata/annual/dvi.dat&quot;, skip = 1) # Add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } The following figure shows the plot of the original time series. # Turn data into data frame to plot it in ggplot volcano_dust_df &lt;- data.frame(year = 1500:(1500+length(volcano_dust)-1), dust = volcano_dust) ggplot(data = volcano_dust_df) + geom_line(aes(x = year, y = dust, group = 1)) + xlab(&quot;Year&quot;) + ylab(&quot;Atmospheric levels of volcanic ash&quot;) + theme_clear() We can also plot the autocorrelogram (ACF) and partial autocorrelogram (PACF) to identify any autocorrelation in the time series. # convert data into a time series object volcano_dust_series &lt;- ts(volcano_dust, start = c(1500)) # Compute autocorrelogram with max lag 20 acf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Autocorrelogram volcano dust&quot; ) # Compute the partial autocorrelogram with max lag 20 pacf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Partial autocorrelogram volcano dust&quot; ) # Finding an ARIMA model auto.arima(volcano_dust_series, ic = &quot;aic&quot;) ## Series: volcano_dust_series ## ARIMA(1,0,2) with non-zero mean ## ## Coefficients: ## ar1 ma1 ma2 mean ## 0.4723 0.2694 0.1279 57.5178 ## s.e. 0.0936 0.0969 0.0752 8.4883 ## ## sigma^2 = 4897: log likelihood = -2661.84 ## AIC=5333.68 AICc=5333.81 BIC=5354.45 # fitting the ARIMA(2,0,0) model volcano_dust_arima &lt;- arima(volcano_dust_series, order = c(2, 0, 0)) # forecast 31 years with the ARIMA(2,0,0) model volcano_dust_forecast &lt;- forecast(volcano_dust_arima, h = 31) plot(volcano_dust_forecast, bty = &quot;n&quot;) Example 11.16 implementation of a dynamic linear model NOTE The code for the implementation of DLMs in Stan and Nimble was developed by Paritosh Kumar Roy. This code and other more complex DLM structures are available through his github. Nile river data Measurements of the annual flow of the river Nile at Aswan (formerly Assuan), 1871–1970, in \\(10^8\\) \\(m^3\\), “with apparent change point near 1898” (\\(\\ref{Cobb1978}\\), Table 1, p.249). Stan library(coda) library(ggplot2) library(rstan) library(tidyverse) options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load data for RW case data(&quot;Nile&quot;, package = &quot;datasets&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } J &lt;- length(Nile) y &lt;- as.vector(Nile) Ft &lt;- rep(1, J) Gt &lt;- 1 m0 &lt;- mean(y) C0 &lt;- 100 stan_data &lt;- list( T = J, y = y, F = Ft, G = Gt, m0 = m0, C0 = C0 ) functions { real uous_dlm_ldensity(array[] real y, array[] real F, real G, real V, real W, real m0, real C0, int T){ array[T+1] real a; array[T+1] real R; array[T] real lldata; a[1] = m0; R[1] = C0; for (i in 1:T) { real u; real Q; real A; real L; u = y[i] - F[i] * a[i]; Q = F[i] * R[i] * F[i] + V; A = G * R[i] * F[i] * inv(Q); L = G - A * F[i]; lldata[i] = normal_lpdf(u | 0, sqrt(Q)); a[i+1] = G * a[i] + A * u; R[i+1] = G * R[i] * L + W; } return sum(lldata); } array[] real uous_ffbs_rng(array[] real y, array[] real F, real G, real V, real W, real m0, real C0, int T){ array[T] real theta; array[T] real a; array[T] real R; array[T] real m; array[T] real C; // Kalman filtering real mt = m0; real Ct = C0; for(i in 1:T){ real ft; real Qt; real at; real Rt; real At; at = G * mt; Rt = G * Ct * G + W; ft = F[i] * at; Qt = F[i] * Rt * F[i] + V; At = Rt * F[i] * inv(Qt); mt = at + At * (y[i] - ft); Ct = Rt - At * Qt * At; //store for backward sampling a[i] = at; R[i] = Rt; m[i] = mt; C[i] = Ct; } // backward sampling array[T-1] int ind = sort_indices_desc(linspaced_int_array(T-1,1,T-1)); theta[T] = normal_rng(m[T], sqrt(C[T])); for(i in ind) { real Bt; real ht; real Ht; Bt = C[i] * G * inv(R[i+1]); ht = m[i] + Bt * (theta[i+1] - a[i+1]); Ht = C[i] - Bt * G * C[i]; theta[i] = normal_rng(ht, sqrt(Ht)); } return theta; } } data{ int T; array[T] real y; array[T] real F; real G; real m0; real&lt;lower=0&gt; C0; } parameters{ real&lt;lower=0&gt; tau; real&lt;lower=0&gt; sqrt_W; } model { real V = square(tau); real W = square(sqrt_W); tau ~ std_normal(); sqrt_W ~ std_normal(); target += uous_dlm_ldensity(y, F, G, V, W, m0, C0, T); } generated quantities{ array[T] real theta; real V = square(tau); real W = square(sqrt_W); theta = uous_ffbs_rng(y, F, G, V, W, m0, C0, T); } Example11_16_Nile_Stan &lt;- stan( file = &quot;functions/Example11_16_Nile.stan&quot;, data = stan_data, warmup = 5000, iter = 10000, chains = 3, include = TRUE ) rstan::traceplot(Example11_16_Nile_Stan, pars = c(&quot;tau&quot;,&quot;sqrt_W&quot;)) rstan::traceplot(Example11_16_Nile_Stan, pars = paste0(&quot;theta[&quot;, sample.int(J, size = 4, replace = FALSE), &quot;]&quot;)) stanfit_summary &lt;- summary(Example11_16_Nile_Stan, pars = c(&quot;tau&quot;,&quot;sqrt_W&quot;,&quot;theta&quot;)) head(stanfit_summary$summary) ## mean se_mean sd 2.5% 25% 50% ## tau 30.64389 0.008404629 0.6416821 29.41102 30.20758 30.63576 ## sqrt_W 17.21506 0.011273123 0.8769351 15.51607 16.61797 17.20847 ## theta[1] 1016.64864 0.127256079 14.3621162 988.86719 1006.99701 1016.44117 ## theta[2] 1056.85361 0.133034738 15.7505555 1026.22258 1046.12525 1056.82528 ## theta[3] 1064.38968 0.130097838 15.6423051 1033.54656 1053.91461 1064.57982 ## theta[4] 1104.50003 0.135380603 16.1483639 1073.00301 1093.50408 1104.42296 ## 75% 97.5% n_eff Rhat ## tau 31.07973 31.92418 5829.117 1.000922 ## sqrt_W 17.80102 18.95826 6051.268 1.000392 ## theta[1] 1026.41967 1044.64621 12737.371 1.000461 ## theta[2] 1067.34249 1088.16050 14017.212 1.000192 ## theta[3] 1074.71421 1095.31926 14456.439 1.000053 ## theta[4] 1115.43239 1136.06188 14228.010 1.000098 stan_fit_df &lt;- data.frame(stanfit_summary$summary) |&gt; rownames_to_column() |&gt; filter(str_detect(rowname, &quot;theta&quot;)) |&gt; mutate(date = zoo::as.yearmon(time(Nile))) ggplot(data = stan_fit_df, aes(x = date)) + geom_path(aes(y = mean), col = &quot;blue&quot;, size = 0.6) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.25, col = &quot;gray99&quot;) + theme_clear() + xlab(&quot;year&quot;) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. # TODO: I am still missing the plots for the fitted values here Nimble library(coda) library(ggplot2) library(nimble) library(tidybayes) library(tidyverse) source(&quot;functions/FFBS_functions_nimble.R&quot;) # load necessary functions for ffbs # Load data for one site data(&quot;Nile&quot;, package = &quot;datasets&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Example11_16_Nile_Nimble &lt;- nimbleCode({ tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) Vt &lt;- tau^2 sqrt_Wt_diag ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) Wt &lt;- sqrt_Wt_diag^2 theta_mean[1] &lt;- m0 theta[1] ~ dnorm(theta_mean[1], var = C0) for(t in 1:J) { theta_mean[t+1] &lt;- Gt * theta[t] theta[t+1] ~ dnorm(theta_mean[t+1], var = Wt) yt_mean[t] &lt;- Ft[t] * theta[t+1] yt[t] ~ dnorm(yt_mean[t], var = Vt) } }) # Model specification J &lt;- length(Nile) yt &lt;- as.vector(Nile) Ft &lt;- rep(1, J) Gt &lt;- 1 m0 &lt;- mean(yt) C0 &lt;- 100 const_list &lt;- list(J = J) dat_list &lt;- list(yt = yt, Ft = Ft, Gt = Gt, m0 = m0, C0 = C0) init_list &lt;- list(tau = 0.01, sqrt_Wt_diag = 0.1, theta = rep(0, J+1)) Rmodel &lt;- nimbleModel(Example11_16_Nile_Nimble, constants=const_list, data=dat_list, inits=init_list) Rmodel$initializeInfo() Cmodel &lt;- compileNimble(Rmodel, showCompilerOutput = FALSE) conf &lt;- configureMCMC(Rmodel, monitors = c(&quot;tau&quot;,&quot;sqrt_Wt_diag&quot;,&quot;theta&quot;)) conf$removeSampler(target = &quot;theta[]&quot;) conf$addSampler(target = &quot;theta&quot;, type = &quot;ffbs_uous&quot;, control = list(ytName = &quot;yt&quot;, FtName = &quot;Ft&quot;, VtName = &quot;Vt&quot;, GtName = &quot;Gt&quot;, WtName = &quot;Wt&quot;, m0Name = &quot;m0&quot;, C0Name = &quot;C0&quot;)) conf$printSamplers(byType = TRUE) conf$removeSampler(target = &quot;sqrt_Wt_diag&quot;) conf$addSampler(target = &quot;sqrt_Wt_diag&quot;, type = &quot;RW&quot;, control = list(log = TRUE)) conf$removeSampler(target = &quot;tau&quot;) conf$addSampler(target = &quot;tau&quot;, type = &quot;RW&quot;, control = list(log = TRUE)) conf$printSamplers(byType = TRUE) conf$printSamplers(executionOrder = TRUE) Rmcmc &lt;- buildMCMC(conf) Cmcmc &lt;- compileNimble(Rmcmc, project = Cmodel, resetFunctions = TRUE, showCompilerOutput = TRUE) niters &lt;- 60000 nburnins &lt;- 0.5*niters nchains &lt;- 2 nthins &lt;- 14 post_samples &lt;- runMCMC( Cmcmc, niter = niters, nburnin = nburnins, thin = nthins, nchains = nchains, samplesAsCodaMCMC = TRUE ) post_summary &lt;- nimSummary(post_samples) tidy_post_samples &lt;- post_samples |&gt; tidy_draws() # Traceplots tidy_post_samples |&gt; dplyr::select(.chain, .iteration, .draw, &#39;tau&#39;) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), size = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free_y&quot;, nrow = 1) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) tidy_post_samples |&gt; dplyr::select(.chain, .iteration, .draw, &#39;sqrt_Wt_diag&#39;) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), size = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free_y&quot;, nrow = 1) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) tidy_post_samples |&gt; dplyr::select(.chain, .iteration, .draw, paste0(&#39;theta[&#39;, sample.int(J, size = 4, replace = FALSE),&quot;]&quot;)) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), linewidth = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free_y&quot;, nrow = 2) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) head(post_summary) ## post.mean post.sd q2.5 q50 q97.5 f0 n.eff Rhat ## sqrt_Wt_diag 107.882 61.411 25.266 121.057 188.266 1 2411.150 10.286 ## tau 61.397 60.344 0.026 53.636 143.811 1 550.516 14.878 ## theta[1] 921.261 10.105 901.513 921.241 940.873 1 4284.000 1.047 ## theta[2] 1052.332 75.143 919.073 1108.214 1123.653 1 2634.552 5.371 ## theta[3] 1091.584 78.460 941.369 1148.067 1163.633 1 1756.144 4.556 ## theta[4] 1000.384 53.710 951.858 965.527 1133.013 1 1877.161 2.539 post_sum_theta &lt;- as.data.frame(post_summary) |&gt; rownames_to_column() |&gt; filter(str_detect(rowname, &quot;theta&quot;)) |&gt; mutate(time = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, rowname))) |&gt; dplyr::select(time, post.mean, post.sd, q2.5, q50, q97.5) ggplot(data = post_sum_theta, aes(x = time)) + geom_ribbon(aes(ymin = q2.5, ymax = q97.5), fill = &quot;lightgray&quot;, alpha = 0.7) + geom_path(aes(y = q50), col = &quot;blue&quot;, linewidth = 0.6) + ylab(&quot;&quot;) + xlab(&quot;Time&quot;) + theme_clear() # REVIEW: it is not giving the same results as Stan and the credible intervals # are wider Cnim_postfit_uous &lt;- compileNimble(nim_postfit_uous, showCompilerOutput = FALSE) ## Compiling ## [Note] This may take a minute. ## [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details. post_tau &lt;- tidy_post_samples$tau post_sqrt_Wt_diag &lt;- tidy_post_samples$sqrt_Wt_diag post_ft_list &lt;- lapply(1:length(post_tau), function(i) { post_Vt &lt;- post_tau[i] ^ 2 post_Wt &lt;- post_sqrt_Wt_diag[i] ^ 2 post_ft &lt;- Cnim_postfit_uous( yt = dat_list$yt, Ft = dat_list$Ft, Vt = post_Vt, Gt = dat_list$Gt, Wt = post_Wt, m0 = dat_list$m0, C0 = dat_list$C0 ) post_ft &lt;- data.frame(ft = post_ft) %&gt;% mutate(time = row_number()) return(post_ft) }) tidy_post_ft &lt;- do.call(&quot;rbind&quot;, post_ft_list) ## posterior summaries of ft post_sum_ft &lt;- tidy_post_ft |&gt; group_by(time) |&gt; summarise( post.mean = mean(ft), post.sd = sd(ft), q2.5 = quantile(ft, prob = 0.025), q50 = quantile(ft, prob = 0.50), q97.5 = quantile(ft, prob = 0.975) ) |&gt; ungroup() ggplot(data = post_sum_ft, aes(x = time)) + geom_ribbon(aes(ymin = q2.5, ymax = q97.5), fill = &quot;lightblue&quot;) + geom_path(aes(y = post.mean), col = &quot;red&quot;, linewidth = 0.25) + geom_point(aes(y = yt), size = 0.25) + ylab(&quot;&quot;) + xlab(&quot;Time&quot;) + theme_clear() UK ozone data 11.0.0.1 Stan library(coda) library(ggplot2) library(gridExtra) library(rstan) library(tidyverse) options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load data for RW case UK_ozone &lt;- read.csv(&quot;data/uk_ozone_one_site.csv&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } y &lt;- UK_ozone$ozone temp &lt;- UK_ozone$temp wind &lt;- UK_ozone$wind J &lt;- length(y) p &lt;- 3 # (intercept, wind, temp) Ft &lt;- array(0, dim = c(J, p)) Ft[, 1] &lt;- 1 Ft[, 2] &lt;- (wind[1:J] - mean(wind[1:J])) / sd(wind[1:J]) Ft[, 3] &lt;- (temp[1:J] - mean(temp[1:J])) / sd(temp[1:J]) Gt &lt;- diag(x = 1, nrow = p, ncol = p) m0 &lt;- c(mean(y), 0, 0) C0 &lt;- diag(x = 1, nrow = p, ncol = p) stan_data &lt;- list(T = J, p = p, y = y, F = Ft, G = Gt, m0= m0, C0 = C0) functions { // FFBS for DLM with univariate observation equation and univariate system equation array[] vector uoms_ffbs_rng(array[] real y, array[] vector F, matrix G, real V, matrix W, vector m0, matrix C0, int T, int p){ array[T] vector[p] theta; array[T] vector[p] a; array[T] matrix[p,p] R; array[T] vector[p] m; array[T] matrix[p,p] C; // Kalman filtering vector[p] mt = m0; matrix[p,p] Ct = C0; for(i in 1:T){ real ft; real Qt; vector[p] at; matrix[p,p] Rt; vector[p] At; at = G * mt; Rt = G * Ct * G&#39; + W; ft = F[i]&#39; * at; Qt = quad_form(Rt, F[i]) + V; //F[i]&#39; * Rt * F[i] + V; At = Rt * F[i] * inv(Qt); mt = at + At * (y[i] - ft); Ct = Rt - At * Qt * At&#39;; //store for backward sampling a[i] = at; R[i] = Rt; m[i] = mt; C[i] = Ct; } // backward sampling array[T-1] int ind = sort_indices_desc(linspaced_int_array(T-1,1,T-1)); theta[T] = multi_normal_rng(m[T], C[T]); for(i in ind) { matrix[p,p] Bt; vector[p] ht; matrix[p,p] Ht; Bt = C[i] * G&#39; * inverse(R[i+1]); ht = m[i] + Bt * (theta[i+1] - a[i+1]); Ht = C[i] - Bt * R[i+1] * Bt&#39;; theta[i] = multi_normal_rng(ht, Ht); } return theta; } real uoms_dlm_ldensity(array[] real y, array[] vector F, matrix G, real V, matrix W, vector m0, matrix C0, int T, int p){ array[T+1] vector[p] a; array[T+1] matrix[p, p] R; array[T] real lldata; a[1] = m0; R[1] = C0; for (i in 1:T) { real u; real Q; real Qinv; vector[p] A; matrix[p, p] L; u = y[i] - F[i]&#39; * a[i]; Q = quad_form(R[i],F[i]) + V; //F[i]&#39; * R[i] * F[i] + V; Qinv = inv(Q); // A = G * R[i] * F[i] * Qinv; L = G - A * F[i]&#39;; //lldata[i] = -0.5 * (log(2 * pi()) + log(Q) + Qinv*square(u)); lldata[i] = normal_lpdf(u | 0, sqrt(Q)); // univariate a[i+1] = G * a[i] + A * u; R[i+1] = G * R[i] * L&#39; + W; } return sum(lldata); } array[] real uoms_dlm_one_step_ahead_rng(array[] real y, array[] vector F, matrix G, real V, matrix W, vector m0, matrix C0, int T, int p){ array[T] real yfit; array[T+1] vector[p] a; array[T+1] matrix[p, p] R; array[T] real lldata; a[1] = m0; R[1] = C0; for (i in 1:T) { real u; real Q; real Qinv; vector[p] A; matrix[p, p] L; u = y[i] - F[i]&#39; * a[i]; Q = quad_form(R[i],F[i]) + V; //F[i]&#39; * R[i] * F[i] + V; Qinv = inv(Q); // A = G * R[i] * F[i] * Qinv; L = G - A * F[i]&#39;; yfit[i] = normal_rng(F[i]&#39; * a[i], sqrt(Q)); // univariate a[i+1] = G * a[i] + A * u; R[i+1] = G * R[i] * L&#39; + W; } return yfit; } } data{ int T; int p; array[T] real y; array[T] vector[p] F; matrix[p, p] G; vector[p] m0; cov_matrix[p] C0; } parameters{ real&lt;lower=0&gt; tau; vector&lt;lower=0&gt;[p] sqrt_W_diag; } model { real V = square(tau); matrix[p, p] W = diag_matrix(square(sqrt_W_diag)); tau ~ std_normal(); sqrt_W_diag ~ std_normal(); target += uoms_dlm_ldensity(y, F, G, V, W, m0, C0, T, p); } generated quantities{ array[T] vector[p] theta; array[T] real yfit; real V = square(tau); matrix[p, p] W = diag_matrix(square(sqrt_W_diag)); theta = uoms_ffbs_rng(y, F, G, V, W, m0, C0, T, p); yfit = uoms_dlm_one_step_ahead_rng(y, F, G, V, W, m0, C0, T, p); } Example11_16_UK_Stan &lt;- stan( file = &quot;functions/Example11_16_UK.stan&quot;, data = stan_data, warmup = 5000, iter = 10000, chains = 3, include = TRUE ) ## Warning: There were 3 divergent transitions after warmup. See ## https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup ## to find out why this is a problem and how to eliminate them. ## Warning: Examine the pairs() plot to diagnose sampling problems rstan::traceplot(Example11_16_UK_Stan, pars = c(&quot;tau&quot;, &quot;sqrt_W_diag&quot;, &quot;theta[1,1]&quot;)) rstan::traceplot(Example11_16_UK_Stan, pars = paste0(&quot;theta[&quot;, sample.int(J, size = 4, replace = FALSE), &quot;,1]&quot;)) rstan::traceplot(Example11_16_UK_Stan, pars = paste0(&quot;theta[&quot;, sample.int(J, size = 4, replace = FALSE), &quot;,2]&quot;)) rstan::traceplot(Example11_16_UK_Stan, pars = paste0(&quot;theta[&quot;, sample.int(J, size = 4, replace = FALSE), &quot;,3]&quot;)) fixedpars_summary &lt;- summary(Example11_16_UK_Stan, pars = c(&quot;tau&quot;, &quot;sqrt_W_diag&quot;))$summary fixedpars_summary ## mean se_mean sd 2.5% 25% 50% ## tau 7.3557829 0.004703800 0.3914611 6.59253412 7.0908380 7.3510177 ## sqrt_W_diag[1] 2.6462922 0.007553726 0.6006965 1.50477136 2.2329780 2.6424571 ## sqrt_W_diag[2] 0.2467058 0.001120097 0.1160182 0.08187897 0.1652562 0.2251065 ## sqrt_W_diag[3] 0.5913775 0.005970895 0.5270182 0.01756817 0.1828199 0.4388231 ## 75% 97.5% n_eff Rhat ## tau 7.6161639 8.1418875 6925.950 1.001010 ## sqrt_W_diag[1] 3.0500270 3.8559789 6323.940 1.000710 ## sqrt_W_diag[2] 0.3045374 0.5329845 10728.547 1.000586 ## sqrt_W_diag[3] 0.8532805 1.9277302 7790.626 1.000073 theta_summary &lt;- summary(Example11_16_UK_Stan, pars = c(&quot;theta&quot;))$summary p1 &lt;- data.frame(theta_summary) |&gt; rownames_to_column() |&gt; filter(rowname %in% paste0(&quot;theta[&quot;, 1:J, &quot;,1]&quot;)) |&gt; mutate(date = as.Date(UK_ozone$date[1:J])) |&gt; ggplot(aes(x = date, group = 1)) + geom_path(aes(y = mean), color = &quot;blue&quot;, linewidth = 0.6) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.25, col = &quot;lightgray&quot;) + ggtitle(&quot;Intercept&quot;) + theme_clear() + theme(plot.title = element_text(hjust = 0.5)) p2 &lt;- data.frame(theta_summary) |&gt; rownames_to_column() |&gt; filter(rowname %in% paste0(&quot;theta[&quot;, 1:J, &quot;,2]&quot;)) |&gt; mutate(date = as.Date(UK_ozone$date[1:J])) |&gt; ggplot(aes(x = date)) + geom_path(aes(y = mean), color = &quot;blue&quot;, linewidth = 0.6) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.25, col = &quot;lightgray&quot;) + ggtitle(&quot;Wind&quot;) + theme_clear() + theme(plot.title = element_text(hjust = 0.5)) p3 &lt;- data.frame(theta_summary) |&gt; rownames_to_column() |&gt; filter(rowname %in% paste0(&quot;theta[&quot;, 1:J, &quot;,3]&quot;)) |&gt; mutate(date = as.Date(UK_ozone$date[1:J])) |&gt; ggplot(aes(x = date)) + geom_path(aes(y = mean), color = &quot;blue&quot;, linewidth = 0.6) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.25, col = &quot;lightgray&quot;) + ggtitle(&quot;Temperature&quot;) + theme_clear() + theme(plot.title = element_text(hjust = 0.5)) grid.arrange(p1,p2,p3, ncol = 2) # TODO: I am still missing the plots for the fitted values here 11.0.0.2 Nimble library(coda) library(dplyr) #library(sf) library(ggplot2) library(nimble, warn.conflicts = FALSE) library(nleqslv) library(tidybayes) source(&quot;functions/FFBS_functions_nimble.R&quot;) UK_ozone &lt;- read.csv(&quot;data/uk_ozone_one_site.csv&quot;) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Example11_16_O3_Nimble &lt;- nimbleCode({ tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) for (t in 1:Tt) { Vt[t] &lt;- tau ^ 2 } for (j in 1:p) { sqrt_Wt_diag[j] ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) } Wt[1:p, 1:p] &lt;- nim_diag(x = sqrt_Wt_diag[1:p] ^ 2) mt[1:p, 1] &lt;- m0[1:p] Ct[1:p, 1:p, 1] &lt;- C0[1:p, 1:p] for (t in 1:Tt) { at[1:p, t] &lt;- (Gt[1:p, 1:p] %*% mt[1:p, t])[1:p, 1] Rt[1:p, 1:p, t] &lt;- Gt[1:p, 1:p] %*% Ct[1:p, 1:p, t] %*% t(Gt[1:p, 1:p]) + Wt[1:p, 1:p] ft[t] &lt;- (t(Ft[1:p, t]) %*% at[1:p, t])[1, 1] Qt[t] &lt;- (t(Ft[1:p, t]) %*% Rt[1:p, 1:p, t] %*% Ft[1:p, t] + Vt[t])[1, 1] yt[t] ~ dnorm(mean = ft[t], var = Qt[t]) At[1:p, t] &lt;- (Rt[1:p, 1:p, t] %*% Ft[1:p, t])[1:p, 1] / Qt[t] mt[1:p, t + 1] &lt;- at[1:p, t] + (At[1:p, t] * (yt[t] - ft[t])) Ct[1:p, 1:p, t + 1] &lt;- Rt[1:p, 1:p, t] - (At[1:p, t] %*% t(At[1:p, t])) * Qt[t] } theta[1:p, 1:(Tt + 1)] &lt;- nim_bsample( mt = mt[1:p, 1:(Tt + 1)], Ct = Ct[1:p, 1:p, 1:(Tt + 1)], at = at[1:p, 1:Tt], Gt = Gt[1:p, 1:p], Rt = Rt[1:p, 1:p, 1:Tt] ) }) # Model specification yt &lt;- UK_ozone$ozone temp &lt;- UK_ozone$temp wind &lt;- UK_ozone$wind Tt &lt;- length(yt) p &lt;- 3 # (intercept, wind, temp) Ft &lt;- array(0, dim = c( p, Tt)) Ft[ 1,] &lt;- 1 Ft[ 2,] &lt;- (wind[1:Tt] - mean(wind[1:Tt])) / sd(wind[1:Tt]) Ft[ 3,] &lt;- (temp[1:Tt] - mean(temp[1:Tt])) / sd(temp[1:Tt]) Gt &lt;- diag(x = 1, nrow = p, ncol = p) m0 &lt;- c(mean(yt), 0, 0) C0 &lt;- diag(x = 1, nrow = p, ncol = p) const_list &lt;- list(Tt = Tt, p = p, m0 = m0, C0 = C0) dat_list &lt;- list(yt = yt, Ft = Ft, Gt = Gt) init_list &lt;- list(tau = 0.01, sqrt_Wt_diag = sqrt(rep(0.1, p))) Rmodel &lt;- nimbleModel( Example11_16_O3_Nimble, constants = const_list, data = dat_list, inits = init_list ) Rmodel$initializeInfo() Rmodel$calculate() Cmodel &lt;- compileNimble(Rmodel, showCompilerOutput = FALSE) conf &lt;- configureMCMC(Rmodel, monitors = c(&quot;tau&quot;, &quot;sqrt_Wt_diag&quot;, &quot;theta&quot;, &quot;ft&quot;)) Rmcmc &lt;- buildMCMC(conf) Cmcmc &lt;- compileNimble( Rmcmc, project = Cmodel, resetFunctions = TRUE, showCompilerOutput = FALSE ) niter &lt;- 10000 nburnin &lt;- 0.5 * niter nthin &lt;- 1 start_time &lt;- Sys.time() post_samples &lt;- runMCMC( Cmcmc, niter = niter, nburnin = nburnin, thin = nthin, nchains = 2, samplesAsCodaMCMC = TRUE ) end_time &lt;- Sys.time() run_time &lt;- end_time - start_time run_time post_summary &lt;- nimSummary(post_samples) tidy_post_samples &lt;- post_samples |&gt; tidy_draws() tidy_post_samples |&gt; dplyr::select( .chain, .iteration, .draw, &#39;tau&#39;, &#39;sqrt_Wt_diag[1]&#39;, &#39;sqrt_Wt_diag[2]&#39;, &#39;sqrt_Wt_diag[3]&#39; ) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), linewidth = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free&quot;, nrow = 2) + theme_clear() + theme(panel.grid = element_blank(), strip.background = element_blank()) post_summary[c(&#39;tau&#39;,&#39;sqrt_Wt_diag[1]&#39;,&#39;sqrt_Wt_diag[2]&#39;,&#39;sqrt_Wt_diag[3]&#39;),] ## post.mean post.sd q2.5 q50 q97.5 f0 n.eff Rhat ## tau 8.549 0.550 7.479 8.549 9.617 1 1021.424 1.001 ## sqrt_Wt_diag[1] 2.208 0.731 1.018 2.125 3.768 1 907.450 1.002 ## sqrt_Wt_diag[2] 0.250 0.124 0.075 0.227 0.549 1 1441.798 1.005 ## sqrt_Wt_diag[3] 0.428 0.411 0.012 0.310 1.591 1 875.370 1.003 post_sum_theta &lt;- as.data.frame(post_summary) |&gt; rownames_to_column() |&gt; filter(str_detect(rowname, &quot;theta&quot;)) |&gt; dplyr::select(rowname, q2.5, q50, q97.5) |&gt; separate(rowname, into = c(&quot;x1&quot;, &quot;x2&quot;), sep = &quot;,&quot;) |&gt; mutate(component = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, x1))) |&gt; mutate(time = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, x2))) |&gt; dplyr::select(component, time, q2.5, q50, q97.5) ggplot(data = post_sum_theta, aes(x = time)) + geom_ribbon(aes(ymin = q2.5, ymax = q97.5), fill = &quot;lightgray&quot;, alpha = 0.7) + geom_path(aes(y = q50), col = &quot;blue&quot;, linewidth = 0.4) + facet_wrap( ~ component, nrow = 2, scales = &quot;free&quot;, labeller = label_bquote(theta[.(component)]) ) + ylab(&quot;&quot;) + xlab(&quot;Time&quot;) + theme_clear() + theme(panel.grid = element_blank(), strip.background = element_blank()) # TODO: I am missing the fitted values here "],["exposure.html", "Chapter 12 Exposure assessment-over space and time", " Chapter 12 Exposure assessment-over space and time In this chapter we have seen the many ways in which the time can be added to space in order to characterize random exposure fields. From this chapter, the reader will have gained an understanding of the following topics: Additional power that can be gained in an epidemiological study by combining the contrasts in the process over both time and space while characterizing the stochastic dependencies across both space and time for inferential analysis. Criteria that good approaches to spatio–temporal modelling should satisfy. General strategies for developing such approaches. Separability and non-separability in spatio–temporal models, and how these could be characterize using the Kronecker product of correlation matrices. Examples of the use of spatio–temporal models in modelling environmental exposures. "],["causality.html", "Chapter 13 Causality-roadblocks on the way to it 13.1 Solutions to Selected Exercises", " Chapter 13 Causality-roadblocks on the way to it This chapter contains a discussion of the differences between causality and association. It also covers specific issues that may be encountered in this area when investigating the effects of environmental hazards on health. From this chapter, the reader will have gained an understanding of the following topics: Issues with causality in observational studies. The Bradford–Hill criteria which are a group of minimal conditions necessary to provide adequate evidence of a causal relationship. Ecological bias which may occur when inferences about the nature of individuals are made using aggregated data. The role of exposure variability in determining the extent of ecological bias. Approaches to acknowledging ecological bias in ecological studies. Concentration and exposure response functions. Models for estimating personal exposures including micro-environments. 13.1 Solutions to Selected Exercises 13.1.1 Question 13.16: Load the Italy and China data, described in Example 13.3, and included in the supplementary Bookdown material into R. The data for this exercise follows that of Exercise 13.3, we can load it as follows. A Simpson’s disaggregation occurs when \\(P_1 &gt; P_2\\), while \\(R_1 &lt; R_2\\) and \\(Q_1 &lt; Q_2\\). We compute the empirical values denoted \\(\\hat{P}_1, \\hat{P}_2, \\hat{Q}_1, \\hat{Q}_2, \\hat{R}_1, \\hat{R}_2\\): P_hats = head(vonK_Aggregated_Table$Survived / vonK_Aggregated_Table$Total_Cases, -1) Q_hats = head(vonK_Under70_Table$Survived / vonK_Under70_Table$Total_Cases, -1) R_hats = head(vonK_Over70_Table$Survived / vonK_Over70_Table$Total_Cases, -1) Solution &lt;- tibble( index = c(1, 2), P_hat = P_hats, Q_hat = Q_hats, R_hat = R_hats ) knitr::kable(Solution) Indeed, we see that \\(\\hat{P}_1 = 0.977 &gt; \\hat{P}_2 = 0.956\\), while \\(\\hat{Q}_1 = 0.987 &lt; \\hat{Q}_2 = 0.991\\) and \\(\\hat{R}_1 = 0.902 &lt; \\hat{R}_2 = 0.905\\), hence a Simpson’s disaggregation has occured. 13.1.2 Question 13.17: Using the Italy and China data stratified by the age groups \\(&lt;70\\) and \\(\\geq 70\\), obtain empirical estimates of \\(P_1\\) and \\(P_2\\), as defined in an SDis. In the following questions, assume that \\(P_1\\) and \\(P_2\\) are the population values. 13.1.2.1 i): What are the possible ranges of \\(\\gamma_1\\) and \\(\\gamma_2\\) for a controlled SDis to exist (can you visualize it in the rectangle \\([0,1]^2\\))? Keep all intermediate computations to three decimal precision. We compute \\(R\\) as defined in Theorem 2, with \\(P_i = \\hat{P}_i\\). \\[ R = \\frac{P_2/(1-P_2)}{P_1/(1-P_1)} = \\frac{0.956/0.044}{0.977/0.023} = 0.511. \\] The allowable region defined by Theorem 2 is hence: \\[ \\Gamma &lt; 0.511 \\implies \\frac{\\gamma_2/(1-\\gamma_2)}{\\gamma_1/(1-\\gamma_1)} &lt; 0.511, \\; \\gamma_2 \\leq \\gamma_1. \\] One can plug the above inequality into freeware such as (Desmos)[https://www.desmos.com/] or (Wolfram-Alpha)[https://www.wolframalpha.com/] to visualize the region. 13.1.2.2 ii): Suppose a centered interval for the \\(\\gamma\\)’s are desired, i.e., \\(\\gamma_1 = 1 - \\gamma_2\\). What are the allowable values of \\(\\gamma_1\\) and \\(\\gamma_2\\)? Furthermore, what choices (considering three decimal points) yield the tightest interval for \\(\\beta_i\\)? We can re-write the above by substituting \\(\\gamma_1 = 1 - \\gamma_2\\) as \\[ \\frac{\\gamma_2/(1-\\gamma_2)}{(1-\\gamma_2)(1-(1-\\gamma_2))} = \\left(\\frac{\\gamma_2}{1-\\gamma_2}\\right)^2 &lt; 0.511, \\] which, taking only the positive solution of the square root, yields the allowable interval for \\(\\gamma_2\\) \\[ \\gamma_2 &lt; 0.417, \\] implying that \\(\\gamma_1 &gt; 0.583\\). Being conservative up to three decimal points, the smallest interval is hence \\([0.416, 0.584]\\). 13.1.2.3 iii): Compute empirical estimates of \\(\\beta_1\\) and \\(\\beta_2\\), and interpret these values. Recall that \\(\\beta_1 = Pr(T|\\bar{C}), \\beta_2 = Pr(T|C)\\). In our context, an empirical estimate of \\(\\beta_1\\) is hence the proportion of Chinese patients over 70, and \\(\\beta_2\\) the proportion of Chinese patients under 70. beta_hat_1 &lt;- vonK_Over70_Table$Total_Cases[1] / vonK_Over70_Table$Total_Cases[3] beta_hat_2 &lt;- vonK_Under70_Table$Total_Cases[2] / vonK_Over70_Table$Total_Cases[3] beta_hats &lt;- c(beta_hat_1, beta_hat_2) Solution &lt;- Solution |&gt; add_column(beta_hat = beta_hats) knitr::kable(Solution) We obtain \\(\\hat{\\beta}_1 = 0.616\\) and \\(\\hat{\\beta}_2 = 0.545\\). 13.1.2.4 iv) (Bonus): What is the tightest centered interval at \\(\\frac{1}{2}(\\hat{\\beta}_1 - \\hat{\\beta}_2)\\) for \\(\\gamma_1\\) and \\(\\gamma_2\\) such that a controlled SDis can theoretically exist (assuming population parameters)? How well does it cover the estimated \\(\\hat{\\beta}_i\\) (if at all)? Was the empirically observed SDis surprising given these results? We compute the average: mean(c(beta_hat_1, beta_hat_2)) We wish to have the tightest interval centered at \\(0.581\\) such that \\(\\gamma_1, \\gamma_2\\) satisfy \\[ \\frac{\\gamma_2/(1-\\gamma_2)}{\\gamma_1/(1-\\gamma_1)} &lt; 0.511, \\; \\gamma_2 \\leq \\gamma_1. \\] We can re-write this as follows. The desired interval is \\([0.581-\\gamma, 0.581+\\gamma]\\), setting \\(\\gamma_2 = 0.581-\\gamma, \\gamma_1 = 0.581+\\gamma\\). Using numerical methods accessed via (Wolfram-Alpha)[https://www.wolframalpha.com/], we obtain the inequality \\[ \\gamma &gt; 0.081 \\] This indicates that \\(\\gamma = 0.080\\) is a boundary value (at 3 decimal points), and hence the tightest interval is \\([0.501, 0.661]\\), which well-covers the estimated \\(\\hat{\\beta}\\). This indicates that perhaps the empirical existence of an SDis is not so surprising. 13.1.3 Question 13.18: Stratify the Italy and China data by the age groups \\(&lt;50\\) and \\(\\geq 50\\). Display the corresponding contingency tables. Re-loading the data and re-stratifying: vonK_Data_50 &lt;- mutate( vonK_Data, .keep = &quot;unused&quot;, Age_Range = fct_collapse( `Age group`, Over_50 = c(&quot;50-59&quot;, &quot;60-69&quot;, &quot;70-79&quot;, &quot;80+&quot;), other_level = &quot;Under_50&quot; ) ) 13.1.3.1 i): Does an SDis still occur? Why or why not? We reproduce the contingency tables of Exercise 13.16. vonK_Data_50 &lt;- vonK_Data_50 |&gt; group_by(Age_Range, Country) |&gt; summarise( Fatalities = sum(`Confirmed fatalities`), Total_Cases = sum(`Confirmed cases`), .groups = &quot;drop_last&quot; ) |&gt; mutate(Survived = Total_Cases - Fatalities, .before = Total_Cases) |&gt; arrange(Country) |&gt; ungroup() vonK_Aggregated_Table &lt;- vonK_Data_50 |&gt; dplyr::select(-Age_Range) |&gt; group_by(Country) |&gt; summarise_all(.funs = c(sum)) |&gt; adorn_totals(&quot;row&quot;) vonK_Under50_Table &lt;- vonK_Data_50 |&gt; filter(Age_Range == &quot;Under_50&quot;) |&gt; dplyr::select(-Age_Range) |&gt; adorn_totals(&quot;row&quot;) vonK_Over50_Table &lt;- vonK_Data_50 |&gt; filter(Age_Range == &quot;Over_50&quot;) |&gt; dplyr::select(-Age_Range) |&gt; adorn_totals(&quot;row&quot;) Displaying the tables: Now, checking if an SDis still occurs. P_hats &lt;- head(vonK_Aggregated_Table$Survived / vonK_Aggregated_Table$Total_Cases, -1) Q_hats &lt;- head(vonK_Under50_Table$Survived / vonK_Under50_Table$Total_Cases, -1) R_hats &lt;- head(vonK_Over50_Table$Survived / vonK_Over50_Table$Total_Cases, -1) Solution &lt;- tibble( index = c(1, 2), P_hat = P_hats, Q_hat = Q_hats, R_hat = R_hats ) knitr::kable(Solution) An SDis no longer occurs. \\(\\hat{P}_1 = 0.977 &gt; \\hat{P}_2 = 0.956\\), but \\(\\hat{R}_1 = 0.960 &gt; \\hat{R}_2 = 0.943\\) also. Probabilistically: different definitions of the random variables involved change the probabilities (empirical or population), and an SDis is not at all guaranteed to appear, even under the same dataset. Conceptually: see Figure 1 in Von Kügelen et al. Although each 10-year range results in a higher CFR for China, the aggregated data shows a higher CFR for Italy. This is exactly Simpson’s paradox. The same aggregation phenomenon happens in our binarization, resulting in a smaller version of Simpson’s paradox. By aggregating the bins 50-80+, we have produced an estimate where the Italian CFR is higher than the Chinese, resulting in a similar bin to the “Total” one given in Figure 1. 13.1.3.2 ii): Compute \\(\\hat{\\beta}_1\\) and \\(\\hat{\\beta}_2\\), and repeat the bonus question of Exercise 13.17. What has changed? Do the changes match your observations? Note that because the aggregated data does not change from Exercise 13.17, our estimates for \\(P_1\\) and \\(P_2\\) also remain the same. Therefore, the allowable region for \\(\\gamma_i\\) does not change: \\[ \\frac{\\gamma_2/(1-\\gamma_2)}{\\gamma_1/(1-\\gamma_1)} &lt; 0.511, \\; \\gamma_2 \\leq \\gamma_1. \\] We first compute \\(\\hat{\\beta_i}\\) again. beta_hat_1 &lt;- vonK_Over50_Table$Total_Cases[1] / vonK_Over50_Table$Total_Cases[3] beta_hat_2 &lt;- vonK_Under50_Table$Total_Cases[1] / vonK_Over50_Table$Total_Cases[3] beta_hats &lt;- c(beta_hat_1, beta_hat_2) print(beta_hats) We obtain \\(\\hat{\\beta}_1 = 0.793\\), while \\(\\hat{\\beta}_2 = 0.688\\). We compute their mid-point to be \\(0.741\\). Hence, we look for an interval of the form \\([0.741 - \\gamma, 0.741 + \\gamma]\\). Repeating the exercise, we obtain \\[ \\gamma &gt; 0.063. \\] Taking \\(\\gamma = 0.064\\), this results in the interval \\([0.677, 0.805]\\). our estimated \\(\\hat{\\beta}_i\\) does still fall in this interval, but it is near the boundary values. This perhaps suggests that an SDis was less likely to occur in this stratification (and indeed, it does not occur empirically). "],["monitoring.html", "Chapter 14 Better monitoring network design-getting better measurements", " Chapter 14 Better monitoring network design-getting better measurements This chapter looks at the emergence of a central purpose; to explore or reduce uncertainty about aspects of the environmental processes of interest. One form of uncertainty, aleatory, cannot be reduced by definition whereas with the other, epistemic, where uncertainty can be reduced (see Chapter 3). However that reduction does not stop the original network from becoming sub-optimal over time, pointing to the need to regularly reassess its performance. From that perspective we see that the design criteria must allow for the possibility of ‘gauging’ (adding monitors to) sites that Maximally reduce uncertainty at their space–time points (measuring their responses eliminates their uncertainty); Best minimise uncertainty at other locations; Best inform about process parameters; Best detect non-compliers. From this chapter, the reader will have gained an understanding of many of the challenges that the network designer may face. These involve the following topics: A multiplicity of valid design objectives. Unforeseen and changing objectives. A multiplicity of responses at each site, i.e. which should be monitored. A need to use prior knowledge and to characterise prior uncertainty. A need to formulate realistic process models. A requirement to take advantage of, and integrate with, existing networks. The need to be realistic, meaning to contend with economic as well as administrative demands and constraints. "],["frontiers.html", "Chapter 15 Current frontiers", " Chapter 15 Current frontiers In this chapter the reader will have encountered a selection of new frontiers in spatio– temporal epidemiology including the following: - A number of areas that are currently under active development. - Two modern approaches to addressing the problem of non-stationarity in random spatio– temporal fields; warping and dimension expansion. - How dimension expansion can be used to dramatically reduce non-stationarity and suggest its possible causes. - A powerful approach combining both physical and statistical modelling within a single framework. "],["course.html", "Course", " Course The following is an example of a structure for a course that might be delivered to epidemiologists with an intermediate level of statistics or statistics students who had an interest in epidemiological analysis. Reference is given to the material in the chapters in the book together with suggested times that might be dedicated to that material. Chapter Sections Suggested timing Chapter 1: Why spatio-temporal epidemiology? All 0.5 Week plus background reading Chapter 2: Modelling health risks All excluding 2.6-2.7 1 Week Chapter 3: The importance of uncertainty 3.1-3.4 inclusive 0.5 Week Chapter 4: Embracing uncertainty: the Bayesian approach 4.1-4.5 inclusive 0.5 Week Chapter 5: The Bayesian approach in practice 5.1-5.3 5.7, 5.8 2 Weeks "],["references.html", "References", " References print(sessionInfo()) ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_Canada.utf8 LC_CTYPE=English_Canada.utf8 ## [3] LC_MONETARY=English_Canada.utf8 LC_NUMERIC=C ## [5] LC_TIME=English_Canada.utf8 ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] nleqslv_3.3.4 rstan_2.26.13 gridExtra_2.3 ## [4] coda_0.19-4 tidybayes_3.0.2 forcats_0.5.2 ## [7] stringr_1.4.1 dplyr_1.0.10 purrr_0.3.5 ## [10] readr_2.1.3 tidyr_1.2.1 tibble_3.1.8 ## [13] tidyverse_1.3.2 magrittr_2.0.3 gstat_2.1-0 ## [16] geoR_1.9-2 cowplot_1.1.1 INLA_22.05.07 ## [19] foreach_1.5.2 Matrix_1.5-1 CARBayes_5.3 ## [22] Rcpp_1.0.9 MASS_7.3-58.1 spdep_1.2-7 ## [25] spData_2.2.1 loo_2.5.1 StanHeaders_2.26.13 ## [28] nimble_0.12.2 sf_1.0-9 rgdal_1.6-2 ## [31] sp_1.5-1 ggmap_3.0.1 ggplot2_3.4.0 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.1 backports_1.4.1 spam_2.9-1 ## [4] plyr_1.8.8 igraph_1.3.5 svUnit_1.0.6 ## [7] splines_4.2.2 crosstalk_1.2.0 leaflet_2.1.1 ## [10] inline_0.3.19 digest_0.6.30 htmltools_0.5.3 ## [13] viridis_0.6.2 fansi_1.0.3 checkmate_2.1.0 ## [16] googlesheets4_1.0.1 tzdb_0.3.0 modelr_0.1.10 ## [19] RcppParallel_5.1.5 matrixStats_0.62.0 MCMCpack_1.6-3 ## [22] xts_0.12.2 timechange_0.1.1 tseries_0.10-52 ## [25] prettyunits_1.1.1 jpeg_0.1-9 colorspace_2.0-3 ## [28] rvest_1.0.3 ggdist_3.2.0 haven_2.5.1 ## [31] xfun_0.34 RcppArmadillo_0.11.4.2.1 tcltk_4.2.2 ## [34] callr_3.7.3 crayon_1.5.2 jsonlite_1.8.3 ## [37] survival_3.4-0 zoo_1.8-11 iterators_1.0.14 ## [40] CARBayesdata_3.0 glue_1.6.2 gtable_0.3.1 ## [43] gargle_1.2.1 MatrixModels_0.5-1 V8_4.2.2 ## [46] distributional_0.3.1 pkgbuild_1.3.1 quantmod_0.4.20 ## [49] maps_3.4.1 abind_1.4-5 SparseM_1.81 ## [52] scales_1.2.1 DBI_1.1.3 GGally_2.1.2 ## [55] viridisLite_0.4.1 units_0.8-0 proxy_0.4-27 ## [58] dotCall64_1.0-2 stats4_4.2.2 intervals_0.15.2 ## [61] truncnorm_1.0-8 htmlwidgets_1.5.4 httr_1.4.4 ## [64] arrayhelpers_1.1-0 FNN_1.1.3.1 RColorBrewer_1.1-3 ## [67] posterior_1.3.1 wk_0.7.0 ellipsis_0.3.2 ## [70] pkgconfig_2.0.3 reshape_0.8.9 farver_2.1.1 ## [73] nnet_7.3-18 sass_0.4.2 dbplyr_2.2.1 ## [76] deldir_1.0-6 utf8_1.2.2 tidyselect_1.2.0 ## [79] labeling_0.4.2 rlang_1.0.6 munsell_0.5.0 ## [82] cellranger_1.1.0 tools_4.2.2 cachem_1.0.6 ## [85] cli_3.4.1 generics_0.1.3 splancs_2.01-43 ## [88] broom_1.0.1 evaluate_0.18 fastmap_1.1.0 ## [91] yaml_2.3.6 mcmc_0.9-7 processx_3.8.0 ## [94] knitr_1.40 fs_1.5.2 s2_1.1.0 ## [97] RgoogleMaps_1.4.5.3 nlme_3.1-160 quantreg_5.94 ## [100] xml2_1.3.3 compiler_4.2.2 rstudioapi_0.14 ## [103] curl_4.3.3 png_0.1-7 e1071_1.7-12 ## [106] reprex_2.0.2 spacetime_1.2-8 bslib_0.4.1 ## [109] stringi_1.7.8 highr_0.9 ps_1.7.2 ## [112] fields_14.1 lattice_0.20-45 classInt_0.4-8 ## [115] urca_1.3-3 tensorA_0.36.2 vctrs_0.5.0 ## [118] pillar_1.8.1 lifecycle_1.0.3 lmtest_0.9-40 ## [121] jquerylib_0.1.4 bitops_1.0-7 R6_2.5.1 ## [124] bookdown_0.32 KernSmooth_2.23-20 codetools_0.2-18 ## [127] boot_1.3-28 assertthat_0.2.1 withr_2.5.0 ## [130] fracdiff_1.5-2 hms_1.1.2 quadprog_1.5-8 ## [133] timeDate_4021.107 grid_4.2.2 class_7.3-20 ## [136] rmarkdown_2.18 googledrive_2.0.0 TTR_0.24.3 ## [139] lubridate_1.9.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

[["index.html", "Spatio-temporal methods in environmental epidemiology Introduction", " Spatio-temporal methods in environmental epidemiology Gavin Shaddick, James V. Zidek, and Alexandra M. Schmidt 2022-12-20 Introduction This is the online companion for the book Spatio-temporal methods in environmental epidemiology published in Chapman and Hall/CRC. All the codes used for the examples in the book are presented here to ensure the material is reproducible, transparent, and accessible. Please feel free to contact us if you find any typos, or error in our code Errare humanum est. "],["preface-2nd-edition.html", "Preface (2nd edition)", " Preface (2nd edition) Spatio-Temporal Methods in Environmental Epidemiology is the first book of its kind to specifically address the interface between environmental epidemiology and spatio-temporal modeling. In response to the growing need for collaboration between statisticians and environmental epidemiologists, the book links recent developments in spatio-temporal methodology with epidemiological applications. Drawing on real-life problems, it provides the tools required to exploit advances in methodology when assessing the health risks associated with environmental hazards. Clear guidelines are given to enable the implementation of methodology and estimation of risks in practice. Designed for graduate students in both epidemiology and statistics, the text covers a wide range of topics, from an introduction to epidemiological principles and the foundations of spatio-temporal modeling to new directions for research. It describes traditional and Bayesian approaches and presents the theory of spatial, temporal, and spatio-temporal modeling in the context of its application to environmental epidemiology. The text includes practical examples together with embedded R code and details of specific R packages and the use of other software including Nimble, Stan, and INLA. Online resources associated with the book provide additional code, data, examples, exercises, lab projects, and more. Representing a major new direction in environmental epidemiology, this book—in full color throughout—underscores the increasing need to consider dependencies in both space and time when modeling epidemiological data. Students will learn how to identify and model patterns in spatio-temporal data and to exploit dependencies over both space and time in order to reduce bias and inefficiency. From this book the reader will have gained an understanding of the following topics: The basic concepts of epidemiology and the estimation of risks associated with environmental hazards. Hierarchical modelling with a Bayesian framework. The theory of spatial, temporal and spatio–temporal process needed for environmental health risk analysis. Fundamental questions related to the nature and role of uncertainty in environmental epidemiology and methods which may help answer those questions. Important areas of application within environmental epidemiology together with strategies for building the models that are needed and coping with challenges that arise. Methods and software for the analysis and visualisation of environmental and health. - Examples of R and WinBUGS code are given throughout the book and, together with data for the examples the code, are included in the online resources. Offer a variety of exercises, both theoretical and practical, to assist in the development of the skills needed to perform spatio–temporal analyses. New frontiers and areas of current and future research. "],["why.html", "Chapter 1 Why spatio-temporal epidemiology?", " Chapter 1 Why spatio-temporal epidemiology? This chapter provides a overview of methods for spatio-temporal modelling and their use in epidemiological studies "],["basics.html", "Chapter 2 Epidemiology-the basics", " Chapter 2 Epidemiology-the basics This chapter contains the basic principles of epidemiological analysis and how estimates of the risks associated with exposures can be obtained. From this chapter, the reader will have gained an understanding of the following topics: Methods for expressing risk and their use with different types of epidemiological study. Calculating risks based on calculations of the expected number of health counts in an area, allowing for the age–sex structure of the underlying population. The use of generalised linear models (GLMS) to model counts of disease and case–control indicators. Modelling the effect of exposures on health and allowing for the possible effects of covariates. Cumulative exposures to environmental hazards. "],["uncertainty.html", "Chapter 3 Uncertainty and its reduction", " Chapter 3 Uncertainty and its reduction This chapter contains a discussion of uncertainty, both in terms of statistical modelling and quantification but also in the wider setting of sources of uncertainty outside those normally encountered in statistics. From this chapter, the reader will have gained an understanding of the following topics: Uncertainty can be dichotomised as either qualitative or quantitative, with the former allowing consideration of a wide variety of sources of uncertainty that would be difficult, if not impossible, to quantify mathematically. Quantitative uncertainty can be thought of as comprising both aleatory and epistemic components, the former representing stochastic uncertainty and the latter subjective uncertainty. Methods for assessing uncertainty including eliciting prior information from experts and sensitivity analysis. Indexing quantitative uncertainty using the variance and entropy of the distribution of a random quantity. Uncertainty in post-normal science derives from a wide variety of issues and can lead to high levels of that uncertainty with serious consequences. Understanding uncertainty is therefore a vital feature of modern environmental epidemiology. "],["data.html", "Chapter 4 Data: increasing information and reducing uncertainty", " Chapter 4 Data: increasing information and reducing uncertainty This is a new chapter "],["embracing.html", "Chapter 5 Embracing uncertainty: the Bayesian approach", " Chapter 5 Embracing uncertainty: the Bayesian approach This chapter introduces the Bayesian approach which provides a natural framework for dealing with uncertainty and also for fitting the models that will be encountered later in the book. From this chapter, the reader will have gained an understanding of the following topics: The use of prior distributions to capture beliefs before data are observed. The combination of prior beliefs and information from data to obtain posterior beliefs. The manipulation of prior distributions with likelihoods to formulate posterior distributions and why conjugate priors are useful in this regard. The difference between informative and non-informative priors. The use of the posterior distribution for inference and methods for calculating summary measures. "],["tactics.html", "Chapter 6 Tactics-implementing uncertainty models Example 6.2: Chronic obstructive pulmonary disease (COPD) in England Example 6.3: Fitting a Poisson regression model in Nimble", " Chapter 6 Tactics-implementing uncertainty models This chapter describes methods for implementing Bayesian models when their complexity means that simple, analytic solutions may not be available. From this chapter, the reader will have gained an understanding of the following topics: Analytical approximations to the posterior distribution. Using samples from a posterior distribution for inference and Monte Carlo integration. Methods for direct sampling such as importance and rejection sampling. Markov Chain Monte Carlo (MCMC) and methods for obtaining samples from the required posterior distribution including Metropolis–Hastings and Gibbs algorithms. Using nimble and stan to fit Bayesian models using Gibbs sampling. Integrated Nested Laplace Approximations (INLA) as a method for performing efficient Bayesian inference including the use of R–INLA to implement a wide variety of latent process models. Example 6.2: Chronic obstructive pulmonary disease (COPD) in England We now look at example into the hospital admission rates for chronic obstructive pulmonary disease (COPD) in England between 2001–2010. In England, there are 324 local authority administrative areas each with an observed and expected number of cases. The expected numbers were calculated using indirect standardization by applying the age–sex specific rates for the whole of England to the age–sex population profile of each of the areas. For this example, the following packages are needed ggplot2 and sf. Load the necessary packages. library(ggplot2) library(sf) To create SMR maps, we need to read in the relevant shapefiles. englandlocalauthority.shp and englandlocalauthority.dbf contain the location, shape, and attributes of English local authorities. The function read_sf() from the sf package will read these shapefiles into R. copdmortalityobserved.csv contains the observed number of hospital admissions in England by local authority. copdmortalityexpected.csv contains the expected number of hospital admissions in England by local authority. # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) Print summaries of the observed and expected counts. # Printing first six rows of the observed counts head(observed) ## name Y2001 Y2002 Y2003 Y2004 Y2005 Y2006 Y2007 Y2008 ## 00AA City of London LB 2 0 3 1 1 1 5 1 ## 00AB Barking and Dagenham LB 100 100 122 93 136 97 91 96 ## 00AC Barnet LB 110 102 106 89 99 97 72 84 ## 00AD Bexley LB 109 113 113 96 113 97 94 89 ## 00AE Brent LB 69 89 70 59 61 48 53 46 ## 00AF Bromley LB 120 129 135 124 128 117 120 106 ## Y2009 Y2010 ## 00AA 0 1 ## 00AB 101 78 ## 00AC 78 89 ## 00AD 93 93 ## 00AE 55 43 ## 00AF 107 113 # Printing first six rows of the expected counts head(expected) ## E2001 E2002 E2003 E2004 E2005 E2006 ## 00AA 2.648915 2.68106 2.727112 2.749562 2.808655 2.915977 ## 00AB 63.946730 63.41700 62.567863 61.444884 60.677119 59.678672 ## 00AC 121.795213 121.91534 122.451050 123.201898 124.449563 125.982868 ## 00AD 90.201336 91.24645 91.949050 92.754781 93.674540 94.598593 ## 00AE 76.876437 77.18529 78.017980 78.967493 80.422828 81.785325 ## 00AF 131.182934 132.30521 133.257442 134.520920 136.441229 137.382528 ## E2007 E2008 E2009 E2010 ## 00AA 3.021586 3.114696 3.237998 3.237998 ## 00AB 58.487583 57.701932 57.250524 57.250524 ## 00AC 127.088805 128.825149 131.374946 131.374946 ## 00AD 95.447131 96.832061 97.651369 97.651369 ## 00AE 83.651266 85.265264 87.089119 87.089119 ## 00AF 138.634021 139.508507 140.634084 140.634084 # Summarising the observed counts summary(observed) ## name Y2001 Y2002 Y2003 ## Length:324 Min. : 2.00 Min. : 0.00 Min. : 3.00 ## Class :character 1st Qu.: 35.00 1st Qu.: 38.00 1st Qu.: 38.00 ## Mode :character Median : 50.00 Median : 52.00 Median : 52.00 ## Mean : 68.01 Mean : 69.63 Mean : 73.44 ## 3rd Qu.: 83.50 3rd Qu.: 80.75 3rd Qu.: 83.25 ## Max. :445.00 Max. :438.00 Max. :480.00 ## Y2004 Y2005 Y2006 Y2007 ## Min. : 1.00 Min. : 1.00 Min. : 1.00 Min. : 5.00 ## 1st Qu.: 35.00 1st Qu.: 37.00 1st Qu.: 35.00 1st Qu.: 37.00 ## Median : 49.50 Median : 51.00 Median : 49.00 Median : 50.00 ## Mean : 66.67 Mean : 69.37 Mean : 67.07 Mean : 68.17 ## 3rd Qu.: 81.25 3rd Qu.: 80.50 3rd Qu.: 81.00 3rd Qu.: 79.00 ## Max. :428.00 Max. :395.00 Max. :428.00 Max. :456.00 ## Y2008 Y2009 Y2010 ## Min. : 1.00 Min. : 0.00 Min. : 1.00 ## 1st Qu.: 37.00 1st Qu.: 36.00 1st Qu.: 38.00 ## Median : 51.00 Median : 50.00 Median : 51.00 ## Mean : 71.40 Mean : 67.04 Mean : 68.81 ## 3rd Qu.: 84.25 3rd Qu.: 78.00 3rd Qu.: 81.25 ## Max. :463.00 Max. :394.00 Max. :441.00 # Summarising the expected counts summary(expected) ## E2001 E2002 E2003 E2004 ## Min. : 2.649 Min. : 2.681 Min. : 2.727 Min. : 2.75 ## 1st Qu.: 39.066 1st Qu.: 39.456 1st Qu.: 39.849 1st Qu.: 40.60 ## Median : 51.766 Median : 52.671 Median : 53.487 Median : 54.29 ## Mean : 62.944 Mean : 63.589 Mean : 64.139 Mean : 64.72 ## 3rd Qu.: 74.292 3rd Qu.: 74.974 3rd Qu.: 74.701 3rd Qu.: 74.02 ## Max. :370.913 Max. :371.271 Max. :369.861 Max. :368.87 ## E2005 E2006 E2007 E2008 ## Min. : 2.809 Min. : 2.916 Min. : 3.022 Min. : 3.115 ## 1st Qu.: 41.646 1st Qu.: 42.497 1st Qu.: 43.203 1st Qu.: 44.262 ## Median : 54.765 Median : 55.506 Median : 56.552 Median : 57.522 ## Mean : 65.440 Mean : 66.180 Mean : 67.022 Mean : 67.950 ## 3rd Qu.: 75.003 3rd Qu.: 75.260 3rd Qu.: 75.790 3rd Qu.: 76.935 ## Max. :368.565 Max. :367.838 Max. :368.026 Max. :368.291 ## E2009 E2010 ## Min. : 3.238 Min. : 3.238 ## 1st Qu.: 45.062 1st Qu.: 45.062 ## Median : 58.077 Median : 58.077 ## Mean : 68.901 Mean : 68.901 ## 3rd Qu.: 78.166 3rd Qu.: 78.166 ## Max. :368.940 Max. :368.940 Modelling the raw standardized mortality rates (SMRs) Calculate the raw SMRs as. \\[ \\text{SMR} = \\dfrac{observed}{expected}\\] SMR_raw &lt;- observed[, -1] / expected # Rename columns names(SMR_raw) &lt;- c( &quot;SMR2001&quot;, &quot;SMR2002&quot;, &quot;SMR2003&quot;, &quot;SMR2004&quot;, &quot;SMR2005&quot;, &quot;SMR2006&quot;, &quot;SMR2007&quot;, &quot;SMR2008&quot;, &quot;SMR2009&quot;, &quot;SMR2010&quot; ) # Printing first six rows of raw SMRs head(SMR_raw) ## SMR2001 SMR2002 SMR2003 SMR2004 SMR2005 SMR2006 SMR2007 ## 00AA 0.7550261 0.0000000 1.1000648 0.3636943 0.3560423 0.3429382 1.6547601 ## 00AB 1.5638016 1.5768644 1.9498828 1.5135516 2.2413721 1.6253713 1.5558858 ## 00AC 0.9031554 0.8366462 0.8656520 0.7223915 0.7955030 0.7699460 0.5665330 ## 00AD 1.2084078 1.2384043 1.2289415 1.0349871 1.2063043 1.0253852 0.9848384 ## 00AE 0.8975442 1.1530694 0.8972291 0.7471429 0.7584911 0.5869024 0.6335828 ## 00AF 0.9147531 0.9750183 1.0130766 0.9217897 0.9381329 0.8516367 0.8655884 ## SMR2008 SMR2009 SMR2010 ## 00AA 0.3210586 0.0000000 0.3088328 ## 00AB 1.6637225 1.7641760 1.3624329 ## 00AC 0.6520466 0.5937205 0.6774503 ## 00AD 0.9191171 0.9523676 0.9523676 ## 00AE 0.5394928 0.6315370 0.4937471 ## 00AF 0.7598103 0.7608397 0.8035037 # Summarising raw SMRs summary(SMR_raw) ## SMR2001 SMR2002 SMR2003 SMR2004 ## Min. :0.3883 Min. :0.0000 Min. :0.3616 Min. :0.2778 ## 1st Qu.:0.7900 1st Qu.:0.8272 1st Qu.:0.8519 1st Qu.:0.7636 ## Median :0.9496 Median :1.0168 Median :1.0209 Median :0.9266 ## Mean :1.0349 Mean :1.0508 Mean :1.0895 Mean :0.9812 ## 3rd Qu.:1.2526 3rd Qu.:1.2364 3rd Qu.:1.3071 3rd Qu.:1.1858 ## Max. :1.9861 Max. :2.2181 Max. :2.2483 Max. :1.9811 ## SMR2005 SMR2006 SMR2007 SMR2008 ## Min. :0.3326 Min. :0.3429 Min. :0.3509 Min. :0.3211 ## 1st Qu.:0.7592 1st Qu.:0.7415 1st Qu.:0.7533 1st Qu.:0.7695 ## Median :0.9573 Median :0.9101 Median :0.9305 Median :0.9404 ## Mean :1.0126 Mean :0.9726 Mean :0.9743 Mean :1.0069 ## 3rd Qu.:1.2083 3rd Qu.:1.1586 3rd Qu.:1.1679 3rd Qu.:1.1979 ## Max. :2.2414 Max. :2.0805 Max. :1.8528 Max. :2.0567 ## SMR2009 SMR2010 ## Min. :0.0000 Min. :0.3088 ## 1st Qu.:0.7452 1st Qu.:0.7682 ## Median :0.8777 Median :0.9337 ## Mean :0.9328 Mean :0.9639 ## 3rd Qu.:1.0934 3rd Qu.:1.1335 ## Max. :1.8507 Max. :2.3856 Attach the values of the raw SMRs to the shapefiles. The function merge() allows us to combine a data frame with a shapefile to plot later. # Convert row names to ID column SMR_raw &lt;- tibble::rownames_to_column(SMR_raw, &quot;ID&quot;) # Combine raw SMRs and shapefiles SMRspatial_raw &lt;- merge(england, SMR_raw, by = &quot;ID&quot;) Use ggplot() and geom_sf() to create a map which colours the local authorities by the raw SMR estimate. # Creating breaks for legend in plot range &lt;- seq(min(SMR_raw$SMR2010) - 0.01, max(SMR_raw$SMR2010) + 0.01, length.out = 11) # Creating map of Raw SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = SMRspatial_raw, aes(fill = SMR2010)) + # Break points for colours scale_y_continuous(breaks = range) + # Clear background and plot borders theme( axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank(), rect = element_blank() ) Modelling a Poisson-Gamma with an MCMC implemented in R The following code shows how to implement the MCMC using only R for the COPD example. First, the constants are defined and the necessary vectors are initialized. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 # Number of MCMC iterations L &lt;- 80000 ## Initialize objects used in MCMC # Matrix for sampled values of parameter theta_i theta &lt;- matrix(ncol = length(y), nrow = L) # Matrix for fitted values fitted &lt;- theta # Vector for sampled values of hyper-parameter a a &lt;- c() # Vector for sampled values of hyper-parameter b b &lt;- c() ## Define constants # Sample size N &lt;- length(y) # Parameter of exponential prior for a lambda_a &lt;- 1 # Parameter of exponential prior for b lambda_b &lt;- 1 # standard deviation of the proposal distribution of log a u &lt;- 0.5 # Initialize theta theta[1, ] &lt;- y / E # Initial value sampled from the prior for a # REVIEW: In the example of the book theta ~ Ga(a,a) not Ga(a,b) a &lt;- rexp(1, lambda_a) # Initial value sampled from the prior for b b &lt;- rexp(1, lambda_b) fitted[1, ] &lt;- rpois(N, E * theta[1, ]) Once all the constants and initial values are set we can run the MCMC. The following code shows the MCMC implementation of a Poisson-Gamma model using only R. # Starting from l=2 as l=1 contains the initial values for(l in 2:L) { # Sampling from the posterior full conditional of each theta_i for (i in 1:N) theta[l, i] &lt;- rgamma(1, (y[i] + a[(l - 1)]), rate = (E[i] + b[(l - 1)])) # Sampling from the posterior full conditional of b # b[l] &lt;- b[l-1] # REVIEW: is this part of the comment? b[l] &lt;- rgamma(1, (N * a[(l - 1)] + 1), rate = (sum(theta[l, ]) + lambda_b)) # Metropolis-Hastings step to sample from the full conditional of &quot;a&quot; # the new value receives the current value in case the proposed # value is rejected a[l] &lt;- a[l - 1] # Proposal in the log-scale laprop &lt;- rnorm(1, log(a[l - 1]), u) aprop &lt;- exp(laprop) num &lt;- N * (aprop * (log(b[l])) - lgamma(aprop)) + (aprop - 1) * sum(log(theta[l, ])) - aprop * lambda_a + log(aprop) den &lt;- N * (a[l - 1] * (log(b[l])) - lgamma(a[l - 1])) + (a[(l - 1)] - 1) * sum(log(theta[l, ])) - a[(l - 1)] * lambda_a + log(a[(l - 1)]) ratio &lt;- exp(num - den) unif &lt;- runif(1) # Change the current value if the proposed value is accepted if (unif &lt; ratio) a[l] &lt;- aprop fitted[l,] &lt;- rpois(N, E * theta[l,]) } After running the MCMC, we should check if the chains have converged # Number of burn in samples burnin &lt;- 20000 thin &lt;- 30 # MCMC samples seqaux &lt;- seq(burnin, L, by = thin) # Trace-plots of the parameters xx &lt;- seq(0, 6, length = 2000) par(mfrow = c(2, 2)) # Plot for &quot;a&quot; plot(a[seqaux], type = &quot;l&quot;, bty = &quot;n&quot;) hist(a[seqaux], prob = 1, main = &quot;&quot;) lines(xx, dexp(xx, lambda_a), col = 2, lwd = 2) # COMBAK: This chains are not looking great # Plot for &quot;b&quot; plot(b[seqaux], type = &quot;l&quot;, bty = &quot;n&quot;) hist(b[seqaux], prob = 1, main = &quot;&quot;) lines(xx, dexp(xx, lambda_b), col = 2, lwd = 2) # Traceplots of theta&#39;s par(mfrow = c(3, 3)) for (i in 1:9) plot(theta[seqaux, i], type = &quot;l&quot;, bty = &quot;n&quot;) Given the convergence issues, we can also check the estimated sampled size and Rhat using the package coda. print(&quot;ESS a:&quot;) ## [1] &quot;ESS a:&quot; coda::effectiveSize(a[seqaux]) ## var1 ## 39.00681 print(&quot;ESS b:&quot;) ## [1] &quot;ESS b:&quot; coda::effectiveSize(b[seqaux]) ## var1 ## 42.29559 print(&quot;ESS theta[1]:&quot;) ## [1] &quot;ESS theta[1]:&quot; coda::effectiveSize(theta[seqaux, 1]) ## var1 ## 2001 print(&quot;ESS theta[10]:&quot;) ## [1] &quot;ESS theta[10]:&quot; coda::effectiveSize(theta[seqaux, 10]) ## var1 ## 2001 The variances for the parameters a and b is lower than the recommended minimum of 100. We will go back to this in Chapter 8. Now that we have guaranteed the convergence of the chains, we can look at the posterior summaries. # Posterior summaries of theta_i meantheta &lt;- apply(theta, 2, mean) q025theta &lt;- apply(theta, 2, function(x) quantile(x, 0.025)) q975theta &lt;- apply(theta, 2, function(x) quantile(x, 0.975)) # Plot the mean and 95% CIs for the thetas par(mfrow = c(1, 1)) plot( meantheta, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(q025theta), max(q975theta)) ) for (i in 1:N) segments(i, q025theta[i], i, q975theta[i]) abline(h = 1, lwd = 2, lty = 2) # Posterior summary of fitted values meanfit &lt;- apply(fitted, 2, mean) q025fit &lt;- apply(fitted, 2, function(x) quantile(x, 0.025)) q975fit &lt;- apply(fitted, 2, function(x) quantile(x, 0.975)) # Plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, meanfit, ylim = c(min(q025fit), max(q975fit)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], q025fit[i], y[i], q975fit[i]) abline(a = 0, b = 1) Example 6.3: Fitting a Poisson regression model in Nimble Load nimble package library(&quot;nimble&quot;) The following code is used to fit the Poisson log-linear model seen in Chapter 2 Section … using Nimble First, define the model in Nimble. Example5_3Code &lt;- nimbleCode({ for (i in 1:N) { Y[i] ~ dpois(mu[i]) log(mu[i]) &lt;- log(E[i]) + beta0 + beta1 * X1[i] + betad * X2[i] } # Priors beta0 ~ dnorm (0 , sd = 100) beta1 ~ dnorm (0 , sd = 100) betad ~ dnorm (0 , sd = 100) # Functions of interest: base &lt;- exp(beta0) RR &lt;- exp(beta1) }) Read the data and define the constants, data and initials lists for the Nimble model. # REVIEW: Is this another version of the COPD data? Is there a data dictionary for this dataset? data &lt;- read.csv(&quot;data/DataExample53.csv&quot;, sep = &quot;,&quot;) ex.const &lt;- list( N = 393, E = data$exp_lungc65pls, X1 = as.vector(scale(data$k3)), X2 = as.vector(scale(data$k2)) ) ex.data &lt;- list(Y = data$lungc65pls) inits &lt;- function() list(beta0 = rnorm(1), beta1 = rnorm(1), betad = rnorm(1)) # Define parameters to monitor and run the model params &lt;- c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;betad&quot;, &quot;base&quot;, &quot;RR&quot;) samples &lt;- nimbleMCMC( code = Example5_3Code, data = ex.data, constants = ex.const, inits = inits, monitors = params, niter = 22000, nburnin = 2000, thin = 10, WAIC = TRUE, nchains = 2, samplesAsCodaMCMC = TRUE ) Check the WAIC. samples$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 3049.364 ## Field &quot;lppd&quot;: ## [1] -1514.458 ## Field &quot;pWAIC&quot;: ## [1] 10.22433 Show the trace plots and posterior summaries for each of the parameters. mvSamples &lt;- samples$samples #trace plots of beta1 plot(mvSamples[, c(&quot;beta1&quot;)]) #trace plots of base plot(mvSamples[, c(&quot;base&quot;)]) #trace plots of RR plot(mvSamples[, c(&quot;RR&quot;)]) #posterior summary of base summary(mvSamples[, c(&quot;base&quot;)]) ## ## Iterations = 1:2000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 2000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## 1.1288584 0.0122649 0.0001939 0.0001969 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## 1.105 1.121 1.129 1.137 1.153 #posterior summary of RR summary(mvSamples[, c(&quot;RR&quot;)]) ## ## Iterations = 1:2000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 2000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## 1.0148438 0.0174738 0.0002763 0.0004220 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## 0.981 1.003 1.015 1.026 1.050 "],["strategies.html", "Chapter 7 Strategies-implementing uncertainty models", " Chapter 7 Strategies-implementing uncertainty models This chapter considers both some of the wider issues related to modelling and the generalisability of results and more technical material on the effect of covariates and model selection. From this chapter, the reader will have gained an understanding of the following topics: Why having contrasts in the variables of interest is important in assessing the effects they have on the response variable. The biases that may arise in the presence of covariates and how covariates can affect variable selection and model choice. Hierarchical models and how that can be used to acknowledge dependence between observations. There are issues with using p–values as measures of evidence against a null hypothesis. Basing scientific conclusions on it can lead to non-reproducible results. The use of predictions from exposure models including acknowledging the additional uncertainty involved when using predictions as inputs to a health model. Methods for performing model selection, including the pros and cons of automatic selection procedures. Model selection within the Bayesian setting and how the models themselves can be incorporated into the estimation process using Bayesian Model Averaging. "],["trusted.html", "Chapter 8 But-can the data be trusted", " Chapter 8 But-can the data be trusted This chapter considers some of the issues that will arise when dealing with ‘real data’. Data will commonly have missing values and may be measured with error. This error might be random or may be due to systematic patterns in how it was collected. From this chapter, the reader will have gained an understanding of the following topics: Classification of missing values into missing at random or not at random. Methods for imputing missing values. Various measurement models including classical and Berkson. The attenuation of regression coefficients under measurement error. Preferential sampling, where the process that determines the locations of monitoring sites and the process being modelled are in some ways dependent. How preferential sampling can bias the measurements that arise from environmental monitoring networks "],["Disease.html", "Chapter 9 Disease-spatial patterns Example 9.1: Empirical Bayes and Bayes smoothing of COPD mortality for 2010 Example 9.3: Fitting a conditional spatial model in nimble and stan Example 9.4: Fitting a conditional spatial model using CARBayes Example 9.5: Fitting a conditional model using INLA", " Chapter 9 Disease-spatial patterns This chapter introduces disease mapping and contains the theory for spatial lattice processes and models for performing smoothing of risks over space. From this chapter, the reader will have gained an understanding of the following topics: Disease mapping, where we have seen how to improve estimates of risk by borrowing strength from adjacent regions which can reduce the instability inherent in risk estimates (SMRs) based on small expected numbers. Seen how smoothing can be performed using either the empirical Bayes or fully Bayesian approaches. Been introduced to computational methods for handling areal data. Learned about Besag’s seminal contributions to the field of spatial statistics including the very important concept of a Markov random field. Explored approaches to modelling a real data including the conditional auto regressive models. Seen how Bayesian spatial models for lattice data use nimble, stan, R and R–INLA. Example 9.1: Empirical Bayes and Bayes smoothing of COPD mortality for 2010 Nimble Following Example 6.2 we look back at the hospital admission rates for COPD, in England for 2010. We can implement the same model we used on Example 6.2 using nimble. # Load nimble library(nimble) library(sf) # to read shapefile # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) The following is the code for the Poisson-Gamma model implemented in nimble. Example9_1Nimble &lt;- nimbleCode({ for (i in 1:N) { Y[i] ~ dpois(mu[i]) # REVIEW: There is an intercept in the book, # but then we wouldn&#39;t be able to compare it to example 5.2 mu[i] &lt;- E[i] * theta[i] # REVIEW: Same as before, the example in the book has theta[i] ~ Ga(a,a) theta[i] ~ dgamma(a, b) Y.fit[i] ~ dpois(mu[i]) } # Priors a ~ dexp(lambda_a) b ~ dexp(lambda_b) }) Define the constants, data and initials lists for the nimble model. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 N &lt;- length(y) # parameter of exponential prior for a lambda_a &lt;- 1 # parameter of exponential prior for b lambda_b &lt;- 1 # constants list constants &lt;- list( N = N, E = E, lambda_a = lambda_a, lambda_b = lambda_b ) # data list ex.data &lt;- list(Y = y) # initial values list inits &lt;- list( theta = rgamma(N, 1, 1), a = rexp(1, lambda_a), b = rexp(1, lambda_b), Y.fit = rpois(N, E) ) # parameters to monitor params &lt;- c(&quot;theta&quot;, &quot;a&quot;, &quot;b&quot;, &quot;Y.fit&quot;) # Run model in nimble mcmc.out &lt;- nimbleMCMC( code = Example9_1Nimble, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 50000, nburnin = 20000, thin = 30, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) Show the WAIC, effective sample size, and trace plots for some of the parameters. mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 2416.512 ## Field &quot;lppd&quot;: ## [1] -1060.176 ## Field &quot;pWAIC&quot;: ## [1] 148.0799 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 223.7287 mvSamples &lt;- mcmc.out$samples # trace plot of a plot(mvSamples[, c(&quot;a&quot;)], bty = &quot;n&quot;) # trace plot of b plot(mvSamples[, c(&quot;b&quot;)], bty = &quot;n&quot;) # trace plots of theta for (i in 1:3) plot(mvSamples[, c(paste(&quot;theta[&quot;, i, &quot;]&quot;, sep = &quot;&quot;))], bty = &quot;n&quot;) Now that we have checked the convergence of the chains we can plot the posterior mean and 95% CIs for each of the parameters. # Print posterior summary for parameters a and b summary(mvSamples[, c(&quot;a&quot;, &quot;b&quot;)]) ## ## Iterations = 1:1000 ## Thinning interval = 1 ## Number of chains = 2 ## Sample size per chain = 1000 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## a 11.77 1.046 0.02339 0.06989 ## b 12.12 1.090 0.02436 0.07436 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## a 9.831 11.03 11.75 12.48 13.85 ## b 10.096 11.35 12.08 12.86 14.22 # posterior summaries of theta_i post_summary &lt;- mcmc.out$summary$all.chains |&gt; as.data.frame() |&gt; tibble::rownames_to_column(&quot;variable&quot;) # pot the mean and 95% CIs for the thetas post_theta &lt;- post_summary[grepl(&quot;theta\\\\[&quot;, post_summary$variable), ] par(mfrow = c(1, 1)) plot( post_theta$Mean, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(post_theta$`95%CI_low`), max(post_theta$`95%CI_upp`)) ) for (i in 1:N) segments(i, post_theta$`95%CI_low`[i], i, post_theta$`95%CI_upp`[i]) abline(h = 1, lwd = 2, lty = 2) # posterior summary of fitted values post_fitted &lt;- post_summary[grepl(&quot;Y.fit\\\\[&quot;, post_summary$variable), ] # plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, post_fitted$Mean, ylim = c(min(post_fitted$`95%CI_low`), max(post_fitted$`95%CI_upp`)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], post_fitted$`95%CI_low`[i], y[i], post_fitted$`95%CI_upp`[i]) abline(a = 0, b = 1) Stan Load necessary libraries and data. library(rstan) library(sf) # to read shapefile library(loo) # To calculate WAIC options(mc.cores = parallel::detectCores()) rstan_options(auto_write = TRUE) # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;, row.names = 1) Write the stan model. This model is in a separate file called Example8_1.stan that will be called later. data { int&lt;lower=0&gt; N; real&lt;lower=0&gt; E[N]; // need to indicate that variable is strictly positive int&lt;lower=0&gt; Y[N]; real&lt;lower=0&gt;lambda_a; real&lt;lower=0&gt;lambda_b; } parameters { real&lt;lower=0&gt; theta[N]; real&lt;lower=0&gt; a; real&lt;lower=0&gt; b; } transformed parameters{ real &lt;lower=0&gt; mu[N]; for(i in 1:N){ mu[i]=E[i]*theta[i]; } } model { // likelihood function and prior for theta for(i in 1:N){ Y[i] ~ poisson(mu[i]); theta[i]~gamma(a,b); } a~exponential(lambda_a); b~exponential(lambda_b); } generated quantities { vector [N] log_lik; int&lt;lower=0&gt; yfit [N]; //computing the log_likelihood for each value of the mean mu and the fitted values for(i in 1:N){ log_lik[i]=poisson_lpmf(Y[i] |mu[i]); yfit[i]=poisson_rng(mu[i]); } } Define the data for the model, similar to nimble. # observations y &lt;- observed$Y2010 # offset E &lt;- expected$E2010 N &lt;- length(y) # data list ex.data &lt;- list( N = length(y), Y = y, E = E, lambda_a = 1, lambda_b = 1 ) # Run the model in Stan Ex9_1Stan &lt;- stan( file = &quot;functions/Example9_1.stan&quot;, data = ex.data, chains = 3, iter = 10000, warmup = 3000, thin = 14, # QUESTION: should we explain this? control = list(adapt_delta = 0.8, max_treedepth = 15), init = &quot;random&quot;, pars = c(&quot;a&quot;, &quot;b&quot;, &quot;theta&quot;, &quot;log_lik&quot;, &quot;yfit&quot;), include = TRUE ) Compute the WAIC, show the trace plots and posterior summaries of the parameters. loglik0 &lt;- extract_log_lik(Ex9_1Stan) waic0 &lt;- waic(loglik0) waic0 ## ## Computed from 1500 by 324 log-likelihood matrix ## ## Estimate SE ## elpd_waic -1207.2 7.6 ## p_waic 146.9 3.4 ## waic 2414.4 15.2 ## ## 173 (53.4%) p_waic estimates greater than 0.4. We recommend trying loo instead. # traceplots of parameters a and b traceplot(Ex9_1Stan, pars = c(&quot;a&quot;, &quot;b&quot;)) # traceplots of parameter theta traceplot(Ex9_1Stan, pars = c(&quot;theta[1]&quot;, &quot;theta[2]&quot;, &quot;theta[3]&quot;)) summary_theta &lt;- summary(Ex9_1Stan, pars = c(&quot;theta&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() par(mfrow = c(1, 1)) plot( summary_theta$mean, pch = 19, cex = 0.8, bty = &quot;n&quot;, xlab = &quot;Borough&quot;, ylab = &quot;Posterior Summary Rate&quot;, ylim = c(min(summary_theta$`5%`), max(summary_theta$`95%`)) ) for (i in 1:N) segments(i, summary_theta$`5%`[i], i, summary_theta$`95%`[i]) abline(h = 1, lwd = 2, lty = 2) # Posterior summary of fitted values summary_fit &lt;- summary(Ex9_1Stan, pars = c(&quot;yfit&quot;), probs = c(0.05, 0.95))$summary |&gt; as.data.frame() # Plot mean and 95% CIs for the fitted values par(mfrow = c(1, 1)) plot( y, summary_fit$mean, ylim = c(min(summary_fit$`5%`), max(summary_fit$`95%`)), xlab = &quot;Observed&quot;, ylab = &quot;Fitted&quot;, pch = 19, cex = 0.7, bty = &quot;n&quot; ) for (i in 1:N) segments(y[i], summary_fit$`5%`[i], y[i], summary_fit$`95%`[i]) abline(a = 0, b = 1) Example 9.3: Fitting a conditional spatial model in nimble and stan Nimble In this example we revisit the COPD data from example 6.3. library(ggplot2) # to plot map library(spdep) # read the shapefile (read_sf) and build neighbors list (poly2nb) library(nimble) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # remove axis line ) } # Load data # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;) covariates &lt;- read.csv(file = &quot;data/copdavgscore.csv&quot;) # Merge everything into one data frame copd_df &lt;- cbind(observed, expected) |&gt; merge( covariates, by.x = &quot;code&quot;, by.y = &quot;LA.CODE&quot;, all.x = TRUE, all.y = FALSE ) Analyze the relationship between COPD data and the average deprivation score which is a measure of the socioeconomic status of the patients. copd_df$SMR2010 = copd_df$Y2010 / copd_df$E2010 ggplot(copd_df) + geom_point(aes(x = Average.Score, y = SMR2010)) + theme_clear() + ylab(&quot;SMR 2010&quot;) + xlab(&quot;Average deprivation score&quot;) Define a function to obtain the number of neighbors. adjlist = function(W, N) { adj = 0 for (i in 1:N) { for (j in 1:N) { if (W[i, j] == 1) { adj = append(adj, j) } } } adj = adj[-1] return(adj) } Define the adjacency matrix and indexes for stan using the nb2mat and adjlist # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) # Define the spatial structure to use in stan N &lt;- length(unique(england$ID)) neigh &lt;- adjlist(W.mat, N) numneigh &lt;- apply(W.mat,2,sum) Example9_3Nimble &lt;- nimbleCode({ # Likelihood for (i in 1:N) { y[i] ~ dpois(lambda[i]) log(lambda[i]) &lt;- log(E[i]) + b[i] + beta0 + beta1*x[i] } # Priors beta0 ~ dnorm(0, sd = 1) beta1 ~ dnorm(0, sd = 1) b[1:N] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N], tau, zero_mean = 1) tau &lt;- 1 / (sigma_b ^ 2) sigma_b ~ T(dnorm(0, sd = 1), 0,) # Fitted values and likelihood for WAIC for (i in 1:N) { fitted[i] ~ dpois(lambda[i]) } }) Define the constants, data and initial values lists and run the model. # constants list constants &lt;- list( N = N, E = copd_df$E2010, L = length(neigh), adj = neigh, weights = rep(1, length(neigh)), num = as.vector(numneigh), p = 3 ) # data list ex.data &lt;- list(y = copd_df$Y2010, x = as.vector(scale(copd_df$Average.Score))) # vector of covariates inits &lt;- list( beta0 = rnorm(1), beta1 = rnorm(1), fitted = rpois(N, 2), sigma_b = 1, b = rnorm(N) ) params &lt;- c(&quot;beta0&quot;,&quot;beta1&quot;, &quot;fitted&quot;, &quot;b&quot;, &quot;sigma_b&quot;) # Run model in nimble mcmc.out &lt;- nimbleMCMC( code = Example9_3Nimble, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 40000, nburnin = 20000, thin = 80, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) Show the WAIC, effective sample size, and trace plots for some of the parameters. mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 2391.822 ## Field &quot;lppd&quot;: ## [1] -1079.933 ## Field &quot;pWAIC&quot;: ## [1] 115.9779 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 298.8577 plot(mcmc.out$samples[, c(&quot;beta0&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;beta1&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;b[2]&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;sigma_b&quot;)], bty = &quot;n&quot;) # Extract samples variables &lt;- c(&quot;beta0&quot;, &quot;beta1&quot;,&quot;sigma_b&quot;) summary_CAR_nimble &lt;- mcmc.out$summary$all.chains summary_CAR_nimble[variables,] ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## beta0 -0.06915965 -0.06892561 0.007660688 -0.08398871 -0.05369503 ## beta1 0.18250693 0.18208533 0.012633190 0.15912279 0.20664645 ## sigma_b 0.25768272 0.25745328 0.022281373 0.21402771 0.30066069 Map the mean of the posterior estimate for the latent effect. samples_CAR_b &lt;- summary_CAR_nimble[grepl(&quot;b\\\\[&quot;, rownames(summary_CAR_nimble)), ] |&gt; as.data.frame() observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) samples_CAR_b$ID &lt;- observed$ID CAR_nimble_merge &lt;- merge(england, samples_CAR_b, by = &quot;ID&quot;) ggplot() + # Choose spatial object and column for plotting geom_sf(data = CAR_nimble_merge, aes(fill = Mean)) + # Change legend&#39;s label labs(fill = &#39;Latent effects stan&#39;) + # Clear background and plot borders theme_void() Stan Here, we implement the CAR model using stan. We will need two functions to structure the matrix of neighbors that will be needed in stan. adjlist = function(W, N) { adj = 0 for (i in 1:N) { for (j in 1:N) { if (W[i, j] == 1) { adj = append(adj, j) } } } adj = adj[-1] return(adj) } mungeCARdata4stan = function(adjBUGS, numBUGS) { N = length(numBUGS) nn = numBUGS N_edges = length(adjBUGS) / 2 node1 = vector(mode = &quot;numeric&quot;, length = N_edges) node2 = vector(mode = &quot;numeric&quot;, length = N_edges) iAdj = 0 iEdge = 0 for (i in 1:N) { for (j in 1:nn[i]) { iAdj = iAdj + 1 if (i &lt; adjBUGS[iAdj]) { iEdge = iEdge + 1 node1[iEdge] = i node2[iEdge] = adjBUGS[iAdj] } } } return (list( &quot;N&quot; = N, &quot;N_edges&quot; = N_edges, &quot;node1&quot; = node1, &quot;node2&quot; = node2 )) } Define the adjacency matrix and indexes for stan using the nb2mat and adjlist # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) # Define the spatial structure to use in stan N &lt;- length(unique(england$ID)) neigh &lt;- adjlist(W.mat, N) numneigh &lt;- apply(W.mat, 2, sum) nbs &lt;- mungeCARdata4stan(neigh, numneigh) N &lt;- nbs$N node1 &lt;- nbs$node1 node2 &lt;- nbs$node2 N_edges &lt;- nbs$N_edges Stan model for CAR effects. This model is in a separate file called Example8_3.stan that will be called later. data { int&lt;lower=1&gt; N; int&lt;lower=1&gt; N_edges; int&lt;lower=1&gt; p; matrix[N,p] X; int&lt;lower=1, upper=N&gt; node1[N_edges]; // node1[i] adjacent to node2[i] int&lt;lower=1, upper=N&gt; node2[N_edges]; // and node1[i] &lt; node2[i] int&lt;lower=0&gt; y[N]; // count outcomes vector&lt;lower=0&gt;[N] E; // exposure } transformed data { vector[N] log_E = log(E); } parameters { real beta0; // intercept vector[p] beta; vector[N] s; // spatial effects real&lt;lower=0&gt; sigma_s; // marginal standard deviation of spatial effects } transformed parameters { vector[N] b; // latent effect b = sigma_s*s; } model { y ~ poisson_log(log_E + beta0 + X*beta + b); // This is the prior for s! (up to proportionality) target += -0.5 * dot_self(s[node1] - s[node2]); sum(s) ~ normal(0, 0.001 * N); beta0 ~ normal(0.0, 10.0); for(j in 1:p){ beta[j] ~ normal(0.0, 10.0); } sigma_s ~ normal(0.0,1.0); } generated quantities { vector[N] mu=exp(log_E + beta0 + X*beta + b); vector[N] lik; vector[N] log_lik; for(i in 1:N){ lik[i] = exp(poisson_lpmf(y[i] | mu[i] )); log_lik[i] = poisson_lpmf(y[i] | mu[i] ); } } N_edges &lt;- N_edges node1 &lt;- node1 node2 &lt;- node2 N &lt;- N y &lt;- copd_df$Y2010 E &lt;- copd_df$E2010 X &lt;- as.numeric(scale(copd_df$Average.Score)) ex.data &lt;- list( N = N, y = y, E = E, p = 1, X = as.matrix(X), N_edges = N_edges, node1 = node1, node2 = node2 ) Example9_3Stan &lt;- stan( file = &quot;functions/Example9_3.stan&quot;, data = ex.data, warmup = 10000, iter = 20000, chains = 2, thin = 10, pars = c(&quot;beta0&quot;, &quot;beta&quot;,&quot;sigma_s&quot;, &quot;b&quot;, &quot;log_lik&quot;), include = TRUE ) Show traceplots. #computing WAIC using the package loo loglikcar &lt;- extract_log_lik(Example9_3Stan) waiccar &lt;- waic(loglikcar) ## Warning: ## 93 (28.7%) p_waic estimates greater than 0.4. We recommend trying loo instead. waiccar ## ## Computed from 2000 by 324 log-likelihood matrix ## ## Estimate SE ## elpd_waic -1195.9 14.4 ## p_waic 115.8 7.1 ## waic 2391.8 28.8 ## ## 93 (28.7%) p_waic estimates greater than 0.4. We recommend trying loo instead. traceplot(Example9_3Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;,&quot;sigma_s&quot;)) Show the posterior summary for the parameters if interest. Keep in mind that in the stan model the we are sampling the standard deviation of the random effect unlike CARBayes where the variance is obtained. # Extract samples summary_CAR_stan &lt;- summary( Example9_3Stan, pars = c(&quot;beta0&quot;, &quot;beta&quot;,&quot;sigma_s&quot;), probs = c(0.025, 0.975) ) summary_CAR_stan$summary ## mean se_mean sd 2.5% 97.5% n_eff ## beta0 -0.06878327 0.0001706849 0.007705602 -0.08369271 -0.05374283 2038.087 ## beta[1] 0.18210481 0.0002997280 0.012276224 0.15775207 0.20627433 1677.548 ## sigma_s 0.25723439 0.0005042320 0.021012226 0.21857116 0.29889935 1736.534 ## Rhat ## beta0 0.9999435 ## beta[1] 0.9992367 ## sigma_s 0.9992859 Map the mean of the posterior estimate for the latent effect. summary_CAR_stan_b &lt;- summary( Example9_3Stan, pars = c(&quot;b&quot;), probs = c(0.025, 0.975) ) observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) summary_CAR_stan_b$ID &lt;- observed$ID CAR_stan_merge &lt;- merge(england, summary_CAR_stan_b, by = &quot;ID&quot;) ggplot() + # Choose spatial object and column for plotting geom_sf(data = CAR_stan_merge, aes(fill = summary.mean)) + # Change legend&#39;s label labs(fill = &#39;Latent effects stan&#39;) + # Clear background and plot borders theme_void() Example 9.4: Fitting a conditional spatial model using CARBayes Load the necessary libraries and the COPD data. As in example 5.2 englandlocalauthority.shp and it’s related files contain the location, shape, and attributes of English local authorities. library(CARBayes) library(ggplot2) library(sf) library(spdep) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_blank()# remove axis line ) } # Reading in borders england &lt;- read_sf(&quot;data/englandlocalauthority.shp&quot;) # Reading in data observed &lt;- read.csv(file = &quot;data/copdmortalityobserved.csv&quot;, row.names = 1) expected &lt;- read.csv(file = &quot;data/copdmortalityexpected.csv&quot;) covariates &lt;- read.csv(file = &quot;data/copdavgscore.csv&quot;) # Merge everything into one data frame copd_df &lt;- cbind(observed, expected) |&gt; merge( covariates, by.x = &quot;code&quot;, by.y = &quot;LA.CODE&quot;, all.x = TRUE, all.y = FALSE ) copd_df$Average.Score &lt;- as.numeric(scale(copd_df$Average.Score)) To calculate the smoother SMRs, we first need to create a neighborhood structure. The functions poly2nb() and nb2mat() from the spdep package can be used to create this # Create the neighborhood W.nb &lt;- poly2nb(england, row.names = rownames(england)) # Creates a matrix for following function call W.mat &lt;- nb2mat(W.nb, style = &quot;B&quot;) Here, we use first neighbors to define the structure, so any local authority sharing a border are considered neighbors. The function S.CARleroux() allows us to use the neighborhood structure and performs a Bayesian analysis to create a smoothed set of observed values. # Running smoothing model Ex9_4 &lt;- S.CARleroux( # Model Formula formula = Y2010 ~ offset(log(E2010)) + Average.Score, # data frame with data data = copd_df, # Choosing Poisson Regression family = &quot;poisson&quot;, # Neighborhood matrix W = W.mat, # Number of burn in samples burnin = 20000, # Number of MCMC samples n.sample = 100000, thin = 10, rho = 1 ) We can extract the new smoother values from the model output and divide them by the expected values in order to compare both methods. # Creating a dataset with smoothed SMRs in 2010 SMR2010 &lt;- Ex9_4$fitted.values / copd_df$E2010 SMR_smooth &lt;- as.data.frame(SMR2010, row.names = rownames(observed)) # Printing first six rows of smoothed SMRs head(SMR_smooth) ## SMR2010 ## 00AA 0.6748788 ## 00AB 1.3177519 ## 00AC 0.6655513 ## 00AD 0.9451610 ## 00AE 0.7475588 ## 00AF 0.8304525 # Summarizing smoothed SMRs summary(SMR_smooth) ## SMR2010 ## Min. :0.6025 ## 1st Qu.:0.7898 ## Median :0.9008 ## Mean :0.9637 ## 3rd Qu.:1.0830 ## Max. :1.7951 # Summary of the parameters under the CAR model. Ex9_4$summary.results[] ## Mean 2.5% 97.5% n.sample % accept n.effective Geweke.diag ## (Intercept) -0.0689 -0.0842 -0.0537 8000 37.5 7661.5 0.6 ## Average.Score 0.1818 0.1576 0.2063 8000 37.5 2340.4 0.1 ## tau2 0.0644 0.0460 0.0864 8000 100.0 3643.8 -0.2 ## rho 1.0000 1.0000 1.0000 NA NA NA NA Use ggplot() and geom_sf() to plot the map of the latent spatial effect. observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) phi_car &lt;- Ex9_4$samples$phi latent_car_df &lt;- data.frame( phi_mean = apply(phi_car, 2, mean), phi_sd = apply(phi_car, 2, sd) ) # Combine latent spatial effect with england dataset latent_car_df$ID &lt;- observed$ID latent_car_england &lt;- merge(england, latent_car_df, by = &quot;ID&quot;) # Creating map of smoothed SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = latent_car_england, aes(fill = phi_mean)) + labs(fill = &#39;Latent effects CARbayes&#39;) + # Clear background and plot borders theme_void() Example 9.5: Fitting a conditional model using INLA # run the INLA model Ex9_5 &lt;- inla( Y2010 ~ Average.Score + f(ID , model = &quot;besag&quot;, graph = &quot;UK.adj&quot;), family = &quot;poisson&quot;, E = E2010, data = copd_df, control.predictor = list(compute = TRUE) ) Summarize the results # Summarizing smoothed SMRs summary(Ex9_5) ## ## Call: ## c(&quot;inla.core(formula = formula, family = family, contrasts = contrasts, ## &quot;, &quot; data = data, quantiles = quantiles, E = E, offset = offset, &quot;, &quot; ## scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, ## &quot;, &quot; lp.scale = lp.scale, link.covariates = link.covariates, verbose = ## verbose, &quot;, &quot; lincomb = lincomb, selection = selection, control.compute ## = control.compute, &quot;, &quot; control.predictor = control.predictor, ## control.family = control.family, &quot;, &quot; control.inla = control.inla, ## control.fixed = control.fixed, &quot;, &quot; control.mode = control.mode, ## control.expert = control.expert, &quot;, &quot; control.hazard = control.hazard, ## control.lincomb = control.lincomb, &quot;, &quot; control.update = ## control.update, control.lp.scale = control.lp.scale, &quot;, &quot; ## control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, ## &quot;, &quot; inla.call = inla.call, inla.arg = inla.arg, num.threads = ## num.threads, &quot;, &quot; blas.num.threads = blas.num.threads, keep = keep, ## working.directory = working.directory, &quot;, &quot; silent = silent, inla.mode ## = inla.mode, safe = FALSE, debug = debug, &quot;, &quot; .parent.frame = ## .parent.frame)&quot;) ## Time used: ## Pre = 0.431, Running = 0.239, Post = 6.57, Total = 7.24 ## Fixed effects: ## mean sd 0.025quant 0.5quant 0.975quant mode kld ## (Intercept) -0.069 0.008 -0.084 -0.069 -0.054 NA 0 ## Average.Score 0.182 0.012 0.158 0.182 0.206 NA 0 ## ## Random effects: ## Name Model ## ID Besags ICAR model ## ## Model hyperparameters: ## mean sd 0.025quant 0.5quant 0.975quant mode ## Precision for ID 15.94 2.61 11.54 15.69 21.64 NA ## ## Marginal log-Likelihood: -1493.26 ## is computed ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also &#39;control.compute=list(return.marginals.predictor=TRUE)&#39;) observed &lt;- tibble::rownames_to_column(observed, &quot;ID&quot;) phi_car &lt;- Ex9_5$summary.random$ID latent_car_df &lt;- data.frame( phi_mean = phi_car$mean, phi_sd = phi_car$sd ) # Combine latent spatial effect with england dataset latent_car_df$ID &lt;- observed$ID latent_car_england &lt;- merge(england, latent_car_df, by = &quot;ID&quot;) # Creating map of smoothed SMRs in England in 2010 ggplot() + # Choose spatial object and column for plotting geom_sf(data = latent_car_england, aes(fill = phi_mean)) + labs(fill = &#39;Latent effects INLA&#39;) + # Clear background and plot borders theme_void() "],["hazards.html", "Chapter 10 Environmental hazards-spatial models Example 10.1 Example 10.9", " Chapter 10 Environmental hazards-spatial models This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics: Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps. Exploring the underlying structure of spatial data and methods for characterizing dependence over space. Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations. Stationarity and isotropy. Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging). Non-stationarity fields. Example 10.1 Map the locations of the monitoring stations in the UK. library(geoR) library(ggmap) library(spdep) uk_data &lt;- read.csv(&quot;data/uk_ozone_uni.csv&quot;) # create a new variable in &quot;sp&quot; format uk_data_sp &lt;- uk_data coordinates(uk_data_sp) &lt;- ~ longitude + latitude # specify the projection code proj4string(uk_data_sp) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) # Specify the bounding box latLongBox = bbox(uk_data_sp) location = c(latLongBox[1, 1] - 0.2, latLongBox[2, 1] - 0, latLongBox[1, 2] + 0.2, latLongBox[2, 2] + 0.2) # Create map with location dots marked on it in UKOzoneMap &lt;- get_stamenmap( bbox = location, zoom = 6 ) ggmap(UKOzoneMap) + geom_point( data = uk_data, aes( x = longitude, y = latitude, size = ozone, color = ozone ), alpha = 0.45 ) + theme_void() Using the geoR package we can also plot the following: the locations of the sampling sites the concentrations of ozone in relation to the x and y coordinates and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density. uk_data_geo &lt;- as.geodata(uk_data, coords.col = 2:3, data.col = 4) plot(uk_data_geo) Example 10.9 NOTE: This won’t be the real example but I need to compare it to something that I know the answer to, so instead of doing a simulation I will keep going by analyzing the meuse river data Nimble rm(list=ls()) library(sp) library(nimble) data(meuse) # Extract the zinc data in the log scale from the meuse dataset meusesample &lt;- data.frame( y = log(meuse$zinc), x1 = sqrt(meuse$dist), easting = meuse$x / 1000, northing = meuse$y / 1000 ) # Compute the distance matrix Dist &lt;- as.matrix(dist(meusesample[,c(&quot;easting&quot;, &quot;northing&quot;)])) Example10_9Code &lt;- nimbleCode ({ # Covariance matrix spatial effect Sigma[1:n, 1:n] &lt;- (sigma^2)*exp(-distMatrix[1:n,1:n]/phi) + (tau^2)*identityMatrix(d = n) for (site in 1:n) { mean.site[site] &lt;- beta0 + beta1 * x[site] } y[1:n] ~ dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n]) # Set up the priors for the spatial model sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) phi_inv ~ dgamma(shape = 8186.436, rate = 12026.879) phi &lt;- 1/phi_inv # prior for the intercept term beta0 ~ dnorm (0, 10) beta1 ~ dnorm (0, 10) }) Define the constants, data and initials lists for the nimble model. # Get the distance matrix using by turning it into an sf object constants &lt;- list(n = nrow(meusesample)) ex.data &lt;- list(y = meusesample$y, x = meusesample$x1, distMatrix = Dist) params &lt;- c( &quot;tau&quot;, &quot;beta0&quot;, &quot;beta1&quot;, &quot;sigma&quot;, &quot;phi&quot;) inits &lt;- list(tau = 0.1, beta0 = 1, beta1 = 1, sigma = 0.1, phi_inv = 6/max(Dist)) # TODO: I have to check this code with a simulation first mcmc.out &lt;- nimbleMCMC( code = Example10_9Code, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 10000, nburnin = 5000, thin = 14, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] 255.9792 ## Field &quot;lppd&quot;: ## [1] -120.0071 ## Field &quot;pWAIC&quot;: ## [1] 7.982528 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 652.6286 # REVIEW: the effective size for sigma is really low, look at the traceplot # NOTE: there might not be a spatial structure... plot(mcmc.out$samples[, c(&quot;beta0&quot;)]) plot(mcmc.out$samples[, c(&quot;beta1&quot;)]) #plot(mcmc.out$samples[, c(&quot;sigma&quot;)]) plot(mcmc.out$samples[, c(&quot;tau&quot;)]) #plot(mcmc.out$samples[, c(&quot;phi&quot;)]) mcmc.out$summary$all.chains ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## beta0 0.76564724 0.76316426 0.31283607 0.177428888 1.4004890 ## beta1 -0.43406517 -0.44752763 0.26964606 -0.946362908 0.1451615 ## phi 1.47491322 1.47452409 0.01600389 1.443913339 1.5078308 ## sigma 1.51986045 1.51779493 0.09759022 1.340413889 1.7200419 ## tau 0.06554179 0.05685945 0.04518016 0.002752747 0.1656068 "],["Time.html", "Chapter 11 Time-why it also matters Example 11.1 Ground level ozone concentrations Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average Example 11.13 Forecasting ozone levels Example 11.14 Forecasting volcanic ash Example 11.16 implementation of a dynamic linear model", " Chapter 11 Time-why it also matters The chapter contains the theory required for handling time series data. From this chapter, the reader will have gained an understanding of the following topics: That a temporal process consists of both low and high frequency components, the former playing a key role in determining long-term trends while the latter may be associated with shorter-term changes. Techniques for the exploratory analysis of the data generated by the temporal process, including the ACF (correlogram) and PACF (periodogram). Models for irregular (high frequency) components after the regular components (trend) have been removed. Methods for forecasting, including exponential smoothing and ARIMA modelling. The state space modelling approach, which sits naturally within a Bayesian setting and which provides a general framework for most of the classical time series models and many more besides. Implementing time series processes within a Bayesian hierarchical framework. Example 11.1 Ground level ozone concentrations Load the daily and hourly data for one site. library(ggplot2) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # change the format of the date column site_daily$date &lt;- as.Date(site_daily$date, &quot;%m/%d/%Y&quot;) # load hourly data from that same site site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } Plot the daily and hourly time series. # Plot daily data ggplot(data = site_daily) + geom_line(aes(x = date, y = max.ozone, group = 1)) + # draw a line at the first data geom_vline(xintercept = as.Date(&quot;2013-01-01&quot;), color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm) geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + theme_clear() # Plot hourly data ggplot(data = site_hourly,) + geom_line(aes(x = time, y = ozone, group = 1)) + geom_vline(xintercept = 1, color = &quot;grey&quot;) + # 8 hour regulatory standard of 0.075 (ppm). geom_hline(yintercept = 0.075, color = &quot;grey&quot;) + xlab(&quot;Hour in 2013&#39;s ozone season&quot;) + ylab(&quot;Hourly Ozone Concentration (ppm)&quot;) + theme_clear() Example 11.2 Low-pass filtering of carbon monoxide levels using the moving average For this example we will use the TTR package (Technical Trading Rules). This allow us to manipulate objects like time series for forecasting. library(TTR) # Load daily data site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # add an identifier column for each day in the sample site_daily$day &lt;- 1:nrow(site_daily) # add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } # Add loess smooth # Single day ozone.loess &lt;- loess(max.ozone ~ day, span = 0.75, data = site_daily[,c(&quot;max.ozone&quot;, &quot;day&quot;)]) ozone.predict &lt;- predict(ozone.loess, data.frame(day = 1:nrow(site_daily))) ozone.predict_df &lt;- data.frame(day = 1:nrow(site_daily), ozone.prediction = ozone.predict) ggplot(data = site_daily) + geom_line(aes(x = day, y = max.ozone, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Single day&quot;) + theme_clear() # Three days ozone_SMA3 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 3), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA3) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Three days&quot;) + theme_clear() # Six days ozone_SMA6 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 6), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA6) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Six days&quot;) + theme_clear() # Twelve days ozone_SMA12 &lt;- data.frame(sma = SMA(site_daily$max.ozone, n = 12), day = 1:nrow(site_daily)) ggplot(data = ozone_SMA12) + geom_line(aes(x = day, y = sma, group = 1)) + geom_line(data = ozone.predict_df, aes(x = day, y = ozone.predict)) + xlab(&quot;Day in 2013 at Los Angeles Site 060379033&quot;) + ylab(&quot;Max Daily 8hr Ozone Level (ppm)&quot;) + ggtitle(&quot;Twelve days&quot;) + theme_clear() Example 11.13 Forecasting ozone levels library(TTR) library(forecast) # Load hourly data for site 060379033 site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # one night hour per day missing for instrument calibration - imputed for simplicity imputeNA &lt;- mean(site_hourly$ozone, na.rm = TRUE) site_hourly$ozone[is.na(site_hourly$ozone)] &lt;- imputeNA # Select the first seven days in july # days_pattern contains the dates for the first seven days days_pattern &lt;- paste0(&quot;^2013070&quot;, 1:7, collapse=&quot;|&quot;) # select all the rows that follow that pattern using grepl july_seven_days &lt;- site_hourly[grepl(days_pattern, site_hourly$datetime),] july_seven_days$hours &lt;- 1:nrow(july_seven_days) # Holt-Winters model fitting # Turn this into a time series object to use Holt-Winters forecast level_ts &lt;- ts(july_seven_days$ozone, frequency = 24, start = c(1)) ozone_forecast &lt;- HoltWinters(level_ts) # Plot using the default function plot( ozone_forecast, xlab = &quot;Hours - First Week -July 2013&quot;, ylab = &quot;O3 (ppm)&quot;, col.predicted = 1, col = &quot;black&quot;, bty = &quot;n&quot;, lty = 2 ) # Holt- Winters 24 ahead forast on Day 8 # no need to specify Holt-Winters forecast as the object is already HoltWinters class ozoneforecast_day8 &lt;- forecast(ozone_forecast, h=24) # Plot using default function plot(ozoneforecast_day8, bty = &quot;n&quot;) Example 11.14 Forecasting volcanic ash The data in this example consists of atmospheric levels of volcanic ash from 1500AD to 2000AD. library(ggplot2) library(forecast) library(TTR) # Load volcano dust data ## REVIEW: Data source: Hyn�d�man, R.J. Time Series Data Library, http://data.is/TSDLdemo # Data cover the period from 1500AD to 2000AD volcano_dust &lt;- scan(&quot;http://robjhyndman.com/tsdldata/annual/dvi.dat&quot;, skip = 1) # Add a theme to clear axes and background in ggplot theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;), # keep axis line ) } The following figure shows the plot of the original time series. # Turn data into data frame to plot it in ggplot volcano_dust_df &lt;- data.frame(year = 1500:(1500+length(volcano_dust)-1), dust = volcano_dust) ggplot(data = volcano_dust_df) + geom_line(aes(x = year, y = dust, group = 1)) + xlab(&quot;Year&quot;) + ylab(&quot;Atmospheric levels of volcanic ash&quot;) + theme_clear() We can also plot the autocorrelogram (ACF) and partial autocorrelogram (PACF) to identify any autocorrelation in the time series. # convert data into a time series object volcano_dust_series &lt;- ts(volcano_dust, start = c(1500)) # Compute autocorrelogram with max lag 20 acf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Autocorrelogram volcano dust&quot; ) # Compute the partial autocorrelogram with max lag 20 pacf( volcano_dust_series, lag.max = 20, bty = &quot;n&quot;, main = &quot;Partial autocorrelogram volcano dust&quot; ) # Finding an ARIMA model auto.arima(volcano_dust_series, ic = &quot;aic&quot;) ## Series: volcano_dust_series ## ARIMA(1,0,2) with non-zero mean ## ## Coefficients: ## ar1 ma1 ma2 mean ## 0.4723 0.2694 0.1279 57.5178 ## s.e. 0.0936 0.0969 0.0752 8.4883 ## ## sigma^2 = 4897: log likelihood = -2661.84 ## AIC=5333.68 AICc=5333.81 BIC=5354.45 # fitting the ARIMA(2,0,0) model volcano_dust_arima &lt;- arima(volcano_dust_series, order = c(2, 0, 0)) # forecast 31 years with the ARIMA(2,0,0) model volcano_dust_forecast &lt;- forecast(volcano_dust_arima, h = 31) plot(volcano_dust_forecast, bty = &quot;n&quot;) Example 11.16 implementation of a dynamic linear model 11.0.1 Nimble library(coda) library(nimble) library(tidybayes) library(tidyverse) # Load sampler functions source(&quot;functions/Ex11_16_FFBS_sampler.R&quot;) # Load data for one site site_daily &lt;- read.csv(&quot;data/LA_ozone_daily.csv&quot;, header = TRUE) # change the format of the date column site_daily$date &lt;- as.Date(site_daily$date, &quot;%m/%d/%Y&quot;) # load hourly data from that same site site_hourly &lt;- read.csv(&quot;data/LA_ozone_hourly.csv&quot;, header = TRUE) # Select the first seven days in July as in Example 11.13 days_pattern &lt;- paste0(&quot;^2013070&quot;, 1:7, collapse=&quot;|&quot;) # select all the rows that follow that pattern using grepl # I know I don&#39;t need to impute it but it was taking forever to compile imputeNA &lt;- mean(site_hourly$ozone, na.rm = TRUE) site_hourly$ozone[is.na(site_hourly$ozone)] &lt;- imputeNA july_seven_days &lt;- site_hourly[grepl(days_pattern, site_hourly$datetime),] july_seven_days$hours &lt;- 1:nrow(july_seven_days) # Add a theme to clear axes and background in ggplot (optional) theme_clear &lt;- function(){ theme( panel.grid.major = element_blank(), # remove background grid panel.grid.minor = element_blank(), panel.background = element_blank(), # remove grey background axis.line = element_line(colour = &quot;black&quot;) # keep axis line ) } 11.0.1.1 Hourly data seasonal component We first analyze the hourly data for the first seven days in July. # The following nimble code was originally written by Paritosh Kumar Roy Example11_16Code &lt;- nimbleCode({ tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) Vt &lt;- tau ^ 2 for (j in 1:p) { sqrt_Wt_diag[j] ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) } Wt[1:p, 1:p] &lt;- diag(sqrt_Wt_diag[1:p] ^ 2) yt[1:Tt] ~ ddlm_uoms( Ft = Ft[1:p, 1:Tt], Vt = Vt, Gt = Gt[1:p, 1:p], Wt = Wt[1:p, 1:p], m0 = m0[1:p], C0 = C0[1:p, 1:p] ) theta[1:p, 1:(Tt + 1)] &lt;- nim_ffbs_uoms( yt = yt[1:Tt], Ft = Ft[1:p, 1:Tt], Vt = Vt, Gt = Gt[1:p, 1:p], Wt = Wt[1:p, 1:p], m0 = m0[1:p], C0 = C0[1:p, 1:p] ) }) # fit a linear growth model for the daily data yt &lt;- july_seven_days$ozone Tt &lt;- length(yt) p &lt;- 3 Ft &lt;- array(0, dim = c(p, Tt)) Ft[1, ] &lt;- 1 Ft[2, ] &lt;- 1 Ft[3, ] &lt;- 0 # Intercept and seasonal component with period of 24hrs Gt &lt;- rbind(c(1, 0, 0), c(0, cos(2 * pi / 12), sin(2 * pi / 12)), c(0, -sin(2 * pi / 12), cos(2 * pi / 12))) # initials m0 &lt;- c(mean(yt, na.rm = TRUE), 0, 0) C0 &lt;- diag(x = 1, nrow = p, ncol = p) const_list &lt;- list(Tt = Tt, p = p, m0 = m0, C0 = C0) dat_list &lt;- list(yt = yt, Ft = Ft, Gt = Gt) init_list &lt;- list( tau = 0.01, sqrt_Wt_diag = sqrt(rep(0.1, p)), theta = array(0, dim = c(p, Tt + 1)) ) Rmodel &lt;- nimbleModel(Example11_16Code, constants = const_list, data = dat_list, inits = init_list) Rmodel$initializeInfo() Rmodel$calculate() Cmodel &lt;- compileNimble(Rmodel, showCompilerOutput = FALSE) conf &lt;- configureMCMC(Rmodel, monitors = c(&quot;tau&quot;, &quot;sqrt_Wt_diag&quot;, &quot;theta&quot;)) conf$printSamplers(byType = TRUE) Rmcmc &lt;- buildMCMC(conf) Cmcmc &lt;- compileNimble( Rmcmc, project = Cmodel, resetFunctions = TRUE, showCompilerOutput = FALSE ) niter &lt;- 40000 nburnin &lt;- 0.5 * niter nthin &lt;- 1 start_time &lt;- Sys.time() post_samples &lt;- runMCMC( Cmcmc, niter = niter, nburnin = nburnin, thin = nthin, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) end_time &lt;- Sys.time() run_time &lt;- end_time - start_time run_time post_summary &lt;- post_samples$summary$all.chains post_summary[c(&#39;tau&#39;, &#39;sqrt_Wt_diag[1]&#39;, &#39;sqrt_Wt_diag[2]&#39;, &#39;sqrt_Wt_diag[3]&#39;), ] ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## tau 0.0010312822 0.0009432750 0.0006832039 4.758700e-05 0.002489829 ## sqrt_Wt_diag[1] 0.0056433888 0.0056596468 0.0004241013 4.751362e-03 0.006451002 ## sqrt_Wt_diag[2] 0.0004525163 0.0003623653 0.0003815168 1.807832e-05 0.001430085 ## sqrt_Wt_diag[3] 0.0004382554 0.0003482520 0.0003674390 1.579212e-05 0.001355956 tidy_post_samples &lt;- post_samples$samples |&gt; tidy_draws() tidy_post_samples |&gt; select( .chain, .iteration, .draw, &#39;tau&#39;, &#39;sqrt_Wt_diag[1]&#39;, &#39;sqrt_Wt_diag[2]&#39;, &#39;sqrt_Wt_diag[3]&#39; ) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), size = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free_y&quot;, nrow = 3) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) post_sum_theta &lt;- as.data.frame(post_summary) |&gt; rownames_to_column() |&gt; filter(str_detect(rowname, &quot;theta&quot;)) |&gt; select(rowname, `95%CI_low`, Mean, `95%CI_upp`)|&gt; separate(rowname, into = c(&quot;x1&quot;, &quot;x2&quot;), sep = &quot;,&quot;) |&gt; mutate(component = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, x1))) |&gt; mutate(time = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, x2))) |&gt; select(component, time, `95%CI_low`, Mean, `95%CI_upp`) ggplot(data = post_sum_theta, aes(x = time)) + #geom_path(aes(y = theta), color = &quot;red&quot;, size = 0.4) + geom_ribbon(aes(ymin = `95%CI_low`, ymax = `95%CI_upp`), fill = &quot;lightgray&quot;, alpha = 0.7) + geom_path(aes(y = Mean), col = &quot;blue&quot;, size = 0.4) + facet_wrap( ~ component, nrow = 2, scales = &quot;free&quot;, labeller = label_bquote(theta[.(component)]) ) + ylab(&quot;&quot;) + xlab(&quot;Time&quot;) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) Define the constants, data and initials lists for the nimble model. n &lt;- ncol(post_samples$samples$chain1) Rhat_all &lt;- sapply(1:n, function(x) { rstan::Rhat(cbind(post_samples$samples$chain1[, x], post_samples$samples$chain2[, x])) }) ess_all &lt;- sapply(1:n, function(x) { rstan::ess_bulk(cbind(post_samples$samples$chain1[, x], post_samples$samples$chain2[, x])) }) ess_all_tail &lt;- sapply(1:n, function(x) { rstan::ess_tail(cbind(post_samples$samples$chain1[, x], post_samples$samples$chain2[, x])) }) max(Rhat_all, na.rm = T) ## [1] 1.000808 min(ess_all, na.rm = T) ## [1] 4144.015 min(ess_all_tail, na.rm = T) ## [1] 5293.313 11.0.1.2 Daily data time varying mean integratedcodeUni &lt;- nimbleCode({ tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) Vt &lt;- tau ^ 2 sqrt_Wt ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) Wt &lt;- sqrt_Wt ^ 2 yt[1:Tt] ~ ddlm_uous(Ft[1:Tt], Vt, Gt, Wt, m0, C0) theta[1:(Tt + 1)] &lt;- nim_ffbs_uous( yt = yt[1:Tt], Ft = Ft[1:Tt], Vt = Vt, Gt = Gt, Wt = Wt, m0 = m0, C0 = C0 ) }) # fit a linear growth model for the daily data yt &lt;- site_daily$max.ozone Tt &lt;- length(yt) Ft &lt;- rep(1, Tt) Gt &lt;- 1 # initial values m0 &lt;- mean(yt, na.rm = TRUE) C0 &lt;- 1 const_list &lt;- list(Tt = Tt, m0 = m0, C0 = C0) dat_list &lt;- list(yt = yt, Ft = Ft, Gt = Gt) init_list &lt;- list( tau = 0.01, sqrt_Wt = sqrt(0.1), theta = rep(0, Tt+1) ) Rmodel &lt;- nimbleModel(integratedcodeUni, constants = const_list, data = dat_list, inits = init_list) Rmodel$initializeInfo() Rmodel$calculate() Cmodel &lt;- compileNimble(Rmodel, showCompilerOutput = FALSE) conf &lt;- configureMCMC(Rmodel, monitors = c(&quot;tau&quot;, &quot;sqrt_Wt&quot;, &quot;theta&quot;)) Rmcmc &lt;- buildMCMC(conf) Cmcmc &lt;- compileNimble( Rmcmc, project = Cmodel, resetFunctions = TRUE, showCompilerOutput = FALSE ) niter &lt;- 20000 nburnin &lt;- 0.5 * niter nthin &lt;- 1 start_time &lt;- Sys.time() post_samples &lt;- runMCMC( Cmcmc, niter = niter, nburnin = nburnin, thin = nthin, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) end_time &lt;- Sys.time() run_time &lt;- end_time - start_time run_time post_summary &lt;- post_samples$summary$all.chains post_summary[c(&#39;tau&#39;, &#39;sqrt_Wt&#39;), ] ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## tau 0.008399282 0.008421366 0.0005684528 0.00723195 0.009453244 ## sqrt_Wt 0.003118875 0.003023848 0.0007965156 0.00181725 0.004930784 tidy_post_samples &lt;- post_samples$samples |&gt; tidy_draws() tidy_post_samples |&gt; select( .chain, .iteration, .draw, &#39;tau&#39;, &#39;sqrt_Wt&#39; ) |&gt; gather(vars, value, -.chain, -.iteration, -.draw) |&gt; ggplot(aes(x = .iteration, y = value)) + geom_path(aes(color = factor(.chain)), size = 0.25, show.legend = FALSE) + facet_wrap( ~ vars, scales = &quot;free_y&quot;, nrow = 3) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) post_sum_theta &lt;- as.data.frame(post_summary) |&gt; rownames_to_column() |&gt; filter(str_detect(rowname, &quot;theta&quot;)) |&gt; select(rowname, `95%CI_low`, Mean, `95%CI_upp`) |&gt; mutate(time = as.numeric(gsub(&quot;.*?([0-9]+).*&quot;, &quot;\\\\1&quot;, rowname))) |&gt; select(time, `95%CI_low`, Mean, `95%CI_upp`) ggplot(data = post_sum_theta, aes(x = time)) + #geom_path(aes(y = theta), color = &quot;red&quot;, size = 0.4) + geom_ribbon(aes(ymin = `95%CI_low`, ymax = `95%CI_upp`), fill = &quot;lightgray&quot;, alpha = 0.7) + geom_path(aes(y = Mean), col = &quot;blue&quot;, size = 0.4) + ylab(&quot;&quot;) + xlab(&quot;Time&quot;) + theme_bw() + theme(panel.grid = element_blank(), strip.background = element_blank()) "],["exposure.html", "Chapter 12 Exposure assessment-over space and time", " Chapter 12 Exposure assessment-over space and time In this chapter we have seen the many ways in which the time can be added to space in order to characterize random exposure fields. From this chapter, the reader will have gained an understanding of the following topics: Additional power that can be gained in an epidemiological study by combining the contrasts in the process over both time and space while characterizing the stochastic dependencies across both space and time for inferential analysis. Criteria that good approaches to spatio–temporal modelling should satisfy. General strategies for developing such approaches. Separability and non-separability in spatio–temporal models, and how these could be characterize using the Kronecker product of correlation matrices. Examples of the use of spatio–temporal models in modelling environmental exposures. "],["causality.html", "Chapter 13 Causality-roadblocks on the way to it", " Chapter 13 Causality-roadblocks on the way to it This chapter contains a discussion of the differences between causality and association. It also covers specific issues that may be encountered in this area when investigating the effects of environmental hazards on health. From this chapter, the reader will have gained an understanding of the following topics: Issues with causality in observational studies. The Bradford–Hill criteria which are a group of minimal conditions necessary to provide adequate evidence of a causal relationship. Ecological bias which may occur when inferences about the nature of individuals are made using aggregated data. The role of exposure variability in determining the extent of ecological bias. Approaches to acknowledging ecological bias in ecological studies. Concentration and exposure response functions. Models for estimating personal exposures including micro-environments. "],["monitoring.html", "Chapter 14 Better monitoring network design-getting better measurements", " Chapter 14 Better monitoring network design-getting better measurements This chapter looks at the emergence of a central purpose; to explore or reduce uncertainty about aspects of the environmental processes of interest. One form of uncertainty, aleatory, cannot be reduced by definition whereas with the other, epistemic, where uncertainty can be reduced (see Chapter 3). However that reduction does not stop the original network from becoming sub-optimal over time, pointing to the need to regularly reassess its performance. From that perspective we see that the design criteria must allow for the possibility of ‘gauging’ (adding monitors to) sites that Maximally reduce uncertainty at their space–time points (measuring their responses eliminates their uncertainty); Best minimise uncertainty at other locations; Best inform about process parameters; Best detect non-compliers. From this chapter, the reader will have gained an understanding of many of the challenges that the network designer may face. These involve the following topics: A multiplicity of valid design objectives. Unforeseen and changing objectives. A multiplicity of responses at each site, i.e. which should be monitored. A need to use prior knowledge and to characterise prior uncertainty. A need to formulate realistic process models. A requirement to take advantage of, and integrate with, existing networks. The need to be realistic, meaning to contend with economic as well as administrative demands and constraints. "],["frontiers.html", "Chapter 15 Current frontiers", " Chapter 15 Current frontiers In this chapter the reader will have encountered a selection of new frontiers in spatio– temporal epidemiology including the following: - A number of areas that are currently under active development. - Two modern approaches to addressing the problem of non-stationarity in random spatio– temporal fields; warping and dimension expansion. - How dimension expansion can be used to dramatically reduce non-stationarity and suggest its possible causes. - A powerful approach combining both physical and statistical modelling within a single framework. "],["course.html", "Course", " Course The following is an example of a structure for a course that might be delivered to epidemiologists with an intermediate level of statistics or statistics students who had an interest in epidemiological analysis. Reference is given to the material in the chapters in the book together with suggested times that might be dedicated to that material. Chapter Sections Suggested timing Chapter 1: Why spatio-temporal epidemiology? All 0.5 Week plus background reading Chapter 2: Modelling health risks All, excluding 2.6-2.7 1 Week Chapter 3: The importance of uncertainty 3.1-3.4 inclusive 0.5 Week "],["references.html", "References", " References print(sessionInfo()) ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_United States.utf8 ## [2] LC_CTYPE=English_United States.utf8 ## [3] LC_MONETARY=English_United States.utf8 ## [4] LC_NUMERIC=C ## [5] LC_TIME=English_United States.utf8 ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] forcats_0.5.2 stringr_1.4.1 dplyr_1.0.10 ## [4] purrr_0.3.5 readr_2.1.3 tidyr_1.2.1 ## [7] tibble_3.1.8 tidyverse_1.3.2 tidybayes_3.0.2 ## [10] coda_0.19-4 forecast_8.19 TTR_0.24.3 ## [13] ggmap_3.0.1 geoR_1.9-2 INLA_22.05.07 ## [16] foreach_1.5.2 Matrix_1.5-1 CARBayes_5.3 ## [19] Rcpp_1.0.9 MASS_7.3-58.1 spdep_1.2-7 ## [22] spData_2.2.0 sp_1.5-0 loo_2.5.1 ## [25] rstan_2.26.13 StanHeaders_2.26.13 nimble_0.12.2 ## [28] sf_1.0-9 ggplot2_3.3.6 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.1 backports_1.4.1 spam_2.9-1 ## [4] plyr_1.8.7 igraph_1.3.5 splines_4.2.2 ## [7] svUnit_1.0.6 crosstalk_1.2.0 leaflet_2.1.1 ## [10] inline_0.3.19 digest_0.6.30 htmltools_0.5.3 ## [13] fansi_1.0.3 magrittr_2.0.3 checkmate_2.1.0 ## [16] googlesheets4_1.0.1 tzdb_0.3.0 modelr_0.1.9 ## [19] RcppParallel_5.1.5 matrixStats_0.62.0 MCMCpack_1.6-3 ## [22] xts_0.12.2 tseries_0.10-52 prettyunits_1.1.1 ## [25] jpeg_0.1-9 colorspace_2.0-3 rvest_1.0.3 ## [28] ggdist_3.2.0 haven_2.5.1 xfun_0.34 ## [31] rgdal_1.6-2 tcltk_4.2.2 callr_3.7.3 ## [34] crayon_1.5.2 jsonlite_1.8.3 survival_3.4-0 ## [37] zoo_1.8-11 iterators_1.0.14 CARBayesdata_3.0 ## [40] glue_1.6.2 gargle_1.2.1 gtable_0.3.1 ## [43] MatrixModels_0.5-1 V8_4.2.1 distributional_0.3.1 ## [46] pkgbuild_1.3.1 quantmod_0.4.20 abind_1.4-5 ## [49] SparseM_1.81 scales_1.2.1 DBI_1.1.3 ## [52] GGally_2.1.2 units_0.8-0 proxy_0.4-27 ## [55] dotCall64_1.0-2 stats4_4.2.2 truncnorm_1.0-8 ## [58] htmlwidgets_1.5.4 httr_1.4.4 arrayhelpers_1.1-0 ## [61] RColorBrewer_1.1-3 ellipsis_0.3.2 wk_0.7.0 ## [64] posterior_1.3.1 pkgconfig_2.0.3 reshape_0.8.9 ## [67] farver_2.1.1 dbplyr_2.2.1 nnet_7.3-18 ## [70] sass_0.4.2 deldir_1.0-6 utf8_1.2.2 ## [73] tidyselect_1.2.0 labeling_0.4.2 rlang_1.0.6 ## [76] cellranger_1.1.0 munsell_0.5.0 tools_4.2.2 ## [79] cachem_1.0.6 cli_3.4.1 generics_0.1.3 ## [82] splancs_2.01-43 broom_1.0.1 evaluate_0.17 ## [85] fastmap_1.1.0 yaml_2.3.6 mcmc_0.9-7 ## [88] fs_1.5.2 processx_3.8.0 knitr_1.40 ## [91] s2_1.1.0 RgoogleMaps_1.4.5.3 nlme_3.1-160 ## [94] quantreg_5.94 xml2_1.3.3 compiler_4.2.2 ## [97] rstudioapi_0.14 curl_4.3.3 png_0.1-7 ## [100] e1071_1.7-12 reprex_2.0.2 bslib_0.4.0 ## [103] stringi_1.7.8 highr_0.9 ps_1.7.2 ## [106] lattice_0.20-45 classInt_0.4-8 tensorA_0.36.2 ## [109] urca_1.3-3 vctrs_0.5.0 pillar_1.8.1 ## [112] lifecycle_1.0.3 lmtest_0.9-40 jquerylib_0.1.4 ## [115] bitops_1.0-7 R6_2.5.1 bookdown_0.29 ## [118] KernSmooth_2.23-20 gridExtra_2.3 codetools_0.2-18 ## [121] boot_1.3-28 assertthat_0.2.1 withr_2.5.0 ## [124] fracdiff_1.5-2 hms_1.1.2 quadprog_1.5-8 ## [127] grid_4.2.2 timeDate_4021.107 class_7.3-20 ## [130] rmarkdown_2.17 googledrive_2.0.0 lubridate_1.8.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

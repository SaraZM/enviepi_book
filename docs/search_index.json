[["hazards.html", "Chapter 10 Environmental hazards-spatial models Example 10.1 Spatial patterns of benzene concentrations in Montreal, QC, Canada Example 10.2: Examining the log concentrations of benzene in Montreal Example 10.5: Variogram Example 10.6 Basic spatial modelling and prediction of benzene in Montreal Example 10.9 Spatial modelling of Benzene in Montreal Example 10.11: INLA, creating a mesh Example 10.12: Fitting an SPDE model using R–INLA: benzene concentration in Montreal Example 10.13: Directional variograms", " Chapter 10 Environmental hazards-spatial models This chapter contains the basic theory for spatial processes and a number of approaches to modelling point-referenced spatial data. From this chapter, the reader will have gained an understanding of the following topics: Visualization techniques needed for both exploring and analyzing spatial data and communicating its features through the use of maps. Exploring the underlying structure of spatial data and methods for characterizing dependence over space. Second-order theory for spatial processes including the covariance. The variogram for measuring spatial associations. Stationarity and isotropy. Methods for spatial prediction, using both classical methods (kriging) as well as modern methods (Bayesian kriging). Non-stationarity fields. Example 10.1 Spatial patterns of benzene concentrations in Montreal, QC, Canada Map the locations of the monitoring stations in Montreal. library(cowplot) library(geoR) library(ggmap) library(spdep) # Load data on benzene concentration in Montreal benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_geo &lt;- benzene_data coordinates(benzene_data_geo) &lt;- ~ lon + lat proj4string(benzene_data_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) # specify the bounding box latLongBox = bbox(benzene_data_geo) location = c(latLongBox[1, 1] - 0.05, latLongBox[2, 1] - 0.05, latLongBox[1, 2] + 0.1, latLongBox[2, 2] + 0.05) # create map with location dots marked on it in MontrelBenzeneMap &lt;- get_stamenmap(bbox = location, zoom = 10) ggmap(MontrelBenzeneMap) + geom_point(data = benzene_data, aes(x = lon, y = lat, size = Benzene), col = &quot;#011f4b&quot;, alpha = 0.45) + theme_void() Using the geoR package we can also plot the following: the locations of the sampling sites the concentrations of ozone in relation to the x and y coordinates and a histogram of the concentrations indicating the distribution of concentrations together with an estimate of the density. # convert data to utm coordinates benzene_data_utm &lt;- spTransform(benzene_data_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_data_utm) colnames(benzene_utm_df) &lt;- c(&quot;Benzene&quot;, &quot;X&quot;, &quot;Y&quot;) # Save as geodata to generate the geodata plot benzene_geodata &lt;- as.geodata(benzene_utm_df, coords.col = 2:3, data.col = 1) plot(benzene_geodata) Example 10.2: Examining the log concentrations of benzene in Montreal # Histogram for the log of the benzene concentration log_histogram &lt;- hist(log(benzene_data$Benzene), main = &quot;&quot;, xlab = &quot;log(Benzene)&quot;) # qqplot for the log of the benzene concentration qqnorm(log(benzene_data$Benzene), bty = &quot;n&quot;); qqline(log(benzene_data$Benzene)) Example 10.5: Variogram library(gstat) benzene_utm_geo &lt;- benzene_utm_df # get the coordinates in kms and turn into a Spatial object benzene_utm_geo[,c(&quot;X&quot;, &quot;Y&quot;)] &lt;- benzene_utm_geo[,c(&quot;X&quot;, &quot;Y&quot;)]/1000 coordinates(benzene_utm_geo) &lt;- ~ X + Y # Plot the variogram and fit one benzene_vgm &lt;- variogram(log(Benzene)~ X + Y, data = benzene_utm_geo) benzene_vgm_fit = fit.variogram(benzene_vgm, model = vgm(0.1, &quot;Exp&quot;,6)) benzene_vgm_fit ## model psill range ## 1 Exp 0.05295422 2.159286 plot(benzene_vgm, benzene_vgm_fit) Example 10.6 Basic spatial modelling and prediction of benzene in Montreal # Generate grid MtlPred &lt;- expand.grid(seq (580, 615 , 0.5), seq (5020, 5060 , 0.5) ) # change names grid names(MtlPred)[ names(MtlPred)==&quot;Var1&quot;] &lt;- &quot;X&quot; names(MtlPred)[ names(MtlPred)==&quot;Var2&quot;] &lt;- &quot;Y&quot; # make the grid a Spatial object coordinates (MtlPred) = ~ X + Y gridded(MtlPred) = TRUE # define the model based on the variogram fit from the previous example mod &lt;- vgm (0.053 , &quot;Exp&quot;, 2.159 ) # use ordinary kriging to predict values in the grid x &lt;- krige(log(Benzene) ~ X + Y, benzene_utm_geo , MtlPred , model = mod ) ## [using universal kriging] # Plot the ordinary kriging predictions and their variance krig_pred &lt;- spplot (x[&quot;var1.pred&quot;], main = &quot;Ordinary kriging predictions &quot;) krig_var &lt;- spplot (x[&quot;var1.var&quot;], main = &quot;Ordinary kriging variance &quot;) plot_grid(krig_pred, krig_var, labels = &quot;auto&quot;) Example 10.9 Spatial modelling of Benzene in Montreal Nimble library(nimble) library(geoR) library(spdep) # Load data on benzene concentration in Montreal benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_geo &lt;- benzene_data coordinates(benzene_data_geo) &lt;- ~ lon + lat proj4string(benzene_data_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_data_utm &lt;- spTransform(benzene_data_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_data_utm) # Change coordinates to kilometers and observations to the log scale Mtl_benzene_sample &lt;- data.frame( y = log(benzene_utm_df$Benzene), easting = benzene_utm_df$lon / 1000, northing = benzene_utm_df$lat / 1000 ) # Compute the distance matrix Dist &lt;- as.matrix(dist(Mtl_benzene_sample[,c(&quot;easting&quot;, &quot;northing&quot;)])) Example10_9Code &lt;- nimbleCode ({ # Covariance matrix spatial effect Sigma[1:n, 1:n] &lt;- (sigma^2)*exp(-distMatrix[1:n,1:n]/phi) + (tau^2)*identityMatrix(d = n) for (site in 1:n) { mean.site[site] &lt;- beta0 + beta1*easting[site] + beta2*northing[site] } y[1:n] ~ dmnorm(mean.site[1:n], cov = Sigma[1:n, 1:n]) # Set up the priors for the spatial model sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) tau ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf) phi_inv ~ dgamma(shape = 5, rate = 5) phi &lt;- 1/phi_inv # prior for the coefficients beta0 ~ dnorm (0, 10) beta1 ~ dnorm (0, 10) beta2 ~ dnorm (0, 10) }) Define the constants, data and initials lists for the nimble model. # Define the constants, data, parameters and initial values constants &lt;- list(n = nrow(Mtl_benzene_sample)) ex.data &lt;- list(y = Mtl_benzene_sample$y, easting = as.vector(scale(Mtl_benzene_sample$easting)), northing = as.vector(scale(Mtl_benzene_sample$northing)), distMatrix = Dist) params &lt;- c( &quot;beta0&quot;, &quot;beta1&quot;,&quot;beta2&quot;, &quot;sigma&quot;, &quot;phi&quot;, &quot;tau&quot;) inits &lt;- list( sigma = 0.1, phi_inv = 6/max(Dist), tau = 0.1) # Run model in nimble mcmc.out &lt;- nimbleMCMC( code = Example10_9Code, constants = constants, data = ex.data, inits = inits, monitors = params, niter = 15000, nburnin = 7000, thin = 14, WAIC = TRUE, nchains = 2, summary = TRUE, samplesAsCodaMCMC = TRUE ) mcmc.out$WAIC ## nimbleList object of type waicList ## Field &quot;WAIC&quot;: ## [1] -32.16285 ## Field &quot;lppd&quot;: ## [1] 19.02601 ## Field &quot;pWAIC&quot;: ## [1] 2.944589 min(coda::effectiveSize(mcmc.out$samples)) ## [1] 448.3656 plot(mcmc.out$samples[, c(&quot;beta0&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;beta1&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;beta2&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;sigma&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;tau&quot;)], bty = &quot;n&quot;) plot(mcmc.out$samples[, c(&quot;phi&quot;)], bty = &quot;n&quot;) mcmc.out$summary$all.chains ## Mean Median St.Dev. 95%CI_low 95%CI_upp ## beta0 0.14576444 0.15245185 0.07965851 -0.03470476 0.2844419 ## beta1 0.05050797 0.04758278 0.06151203 -0.06582232 0.1786680 ## beta2 0.07503045 0.07876951 0.06770073 -0.07367572 0.1978829 ## phi 3.76859343 3.16166514 2.21617195 1.48750707 9.8211529 ## sigma 0.23523442 0.22941975 0.04123602 0.16717329 0.3369308 ## tau 0.08733017 0.09112029 0.03968638 0.00605435 0.1567003 10.0.1 Stan benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_geo &lt;- benzene_data coordinates(benzene_data_geo) &lt;- ~ lon + lat proj4string(benzene_data_geo) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_data_utm &lt;- spTransform(benzene_data_geo, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame benzene_utm_df &lt;- as.data.frame(benzene_data_utm) # change the observed values to the log scale and the coordinates to km&#39;s Mtl_benzene_sample &lt;- data.frame( y = log(benzene_utm_df$Benzene), easting = benzene_utm_df$lon / 1000, northing = benzene_utm_df$lat / 1000 ) # Compute the distance matrix Dist &lt;- as.matrix(dist(Mtl_benzene_sample[,c(&quot;easting&quot;, &quot;northing&quot;)])) data { int&lt;lower=1&gt; N; int&lt;lower=0&gt; p; vector[N] y; matrix[N,N] dist_matrix; matrix[N,p] X; } parameters { real&lt;lower=0&gt; phi; real&lt;lower=0&gt; tau; real&lt;lower=0&gt; sigma; vector[p] beta; real beta0; } model { vector[N] mu; matrix[N, N] L; matrix[N, N] Sigma; real sigma_sq = square(sigma); real tau_sq = square(tau); for(i in 1:(N-1)){ for(j in (i+1):N){ Sigma[i,j] = sigma_sq*exp(-dist_matrix[i,j]/phi); Sigma[j,i] = Sigma[i,j]; } } // diagonal elements for(i in 1:N) { Sigma[i,i] = sigma_sq + tau_sq; mu[i] = beta0 + X[i,]*beta; } L = cholesky_decompose(Sigma); beta0 ~ normal(0,10); beta ~ normal(0,10); phi ~ inv_gamma(5, 5); tau ~ cauchy(0,1); sigma ~ cauchy(0,1); y ~ multi_normal_cholesky(mu, L); } N &lt;- nrow(benzene_utm_df) # Change coordinates to kilometers X &lt;- data.frame(easting = as.vector(scale(Mtl_benzene_sample$easting/1000)), northing = as.vector(scale(Mtl_benzene_sample$northing/1000))) ex.data &lt;- list( N = N, p = 2, y = log(benzene_utm_df$Benzene), dist_matrix = Dist, X = as.matrix(X) ) Example10_9Stan &lt;- stan( file = &quot;functions/Example10_9.stan&quot;, data = ex.data, warmup = 10000, iter = 20000, chains = 2, thin = 10, pars = c(&quot;beta0&quot;, &quot;beta&quot;,&quot;sigma&quot;, &quot;tau&quot;, &quot;phi&quot;), include = TRUE ) traceplot(Example10_9Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;,&quot;sigma&quot;, &quot;tau&quot;, &quot;phi&quot;)) summary_exp_stan &lt;- summary( Example10_9Stan, pars = c(&quot;beta0&quot;,&quot;beta&quot;, &quot;phi&quot;, &quot;sigma&quot;, &quot;tau&quot;), probs = c(0.025, 0.975) ) summary_exp_stan$summary ## mean se_mean sd 2.5% 97.5% n_eff ## beta0 0.15381777 0.0017361857 0.07993500 -0.025880142 0.2988911 2119.735 ## beta[1] 0.05152464 0.0013062054 0.05892381 -0.054253468 0.1783731 2034.973 ## beta[2] 0.07916878 0.0016912817 0.06688711 -0.066852363 0.1955267 1564.059 ## phi 3.64342615 0.0501895357 2.10110303 1.478266734 9.1028812 1752.542 ## sigma 0.23322468 0.0009443012 0.04079159 0.164405436 0.3243540 1866.037 ## tau 0.08662863 0.0009313626 0.03957471 0.008386844 0.1538596 1805.501 ## Rhat ## beta0 0.9993724 ## beta[1] 0.9994953 ## beta[2] 1.0003820 ## phi 1.0000525 ## sigma 1.0002576 ## tau 1.0025965 Example 10.11: INLA, creating a mesh library(geoR) library(INLA) library(spdep) benzene_data &lt;- read.csv(&quot;data/montreal_benzene_apr.csv&quot;) # create a new variable in &quot;sp&quot; format and define coordinates benzene_data_loc &lt;- benzene_data coordinates(benzene_data_loc) &lt;- ~ lon + lat proj4string(benzene_data_loc) &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) benzene_data_utm &lt;- spTransform(benzene_data_loc, CRS(&quot;+proj=utm +zone=18 +ellps=WGS72&quot;)) # Save the utm as a data frame locations_df &lt;- as.data.frame(benzene_data_utm@coords) benzene_utm_df &lt;- data.frame( ID = 1:nrow(benzene_data), X = benzene_data_utm@coords[,1]/1000, Y = benzene_data_utm@coords[,2]/1000, logbenzene = log(benzene_data_utm$Benzene)) # change the observed values to the log scale and the coordinates to km&#39;s mesh = inla.mesh.create(locations_df, cutoff = 0.01, refine =(list(min.angle =20))) plot(mesh , col=&quot;gray&quot;, main=&quot;&quot;) # ukmap &lt;- readShapeLines(&quot;uk_BNG.shp&quot;) plot(mesh , col=&quot;gray&quot;, main=&quot;&quot;) # lines(ukmap) # points(locations , col=&quot;red&quot;, pch=20,bg=&quot;red&quot;) Example 10.12: Fitting an SPDE model using R–INLA: benzene concentration in Montreal # Field std . dev . for theta =0 sigma0 = 1 # find the range of the location data size = min(c(diff(range(mesh$loc[, 1])), diff (range(mesh$loc[, 2])))) # A fifth of the approximate domain width . range0 = size/5 kappa0 = sqrt(8)/range0 tau0 = 1/(sqrt (4*pi)*kappa0*sigma0) spde = inla.spde2.matern ( mesh, B.tau = cbind(log (tau0), -1, +1), B.kappa = cbind(log (kappa0), 0, -1), theta.prior.mean = c(0 , 0), constr = TRUE ) formula = logbenzene ~ 1 + X + Y + f(ID , model = spde) model = inla( formula, family = &quot;gaussian&quot;, data = benzene_utm_df , control.predictor = list(compute = TRUE), control.compute = list(dic = TRUE , config = TRUE) ) model$summary.fixed ## mean sd 0.025quant 0.5quant 0.975quant ## (Intercept) -1.686470286 111.66894219 -182.24776337 -17.506396963 281.76530712 ## X 0.013436242 0.01994953 -0.02334170 0.011813181 0.06151800 ## Y -0.001256258 0.02255075 -0.05792507 0.001917255 0.03521233 ## mode kld ## (Intercept) NA 3.794265e-05 ## X NA 6.757268e-05 ## Y NA 2.544491e-05 Example 10.13: Directional variograms ### Compute and plot the directional variogram CA.geo &lt;- as.geodata( benzene_utm_df , coords.col = 2:3 , data.col=1) CA.vario4 &lt;- variog4(CA.geo ) plot(CA.vario4) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
